2025-06-08 17:59:00,274 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 17:59:05,080 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 17:59:05,119 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 17:59:05,119 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 17:59:05,119 - VulnerabilityEngine - INFO - 将执行 2 个分析passes: ['init', 'cwe78']
2025-06-08 17:59:05,119 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 17:59:05,119 - VulnerabilityEngine - ERROR - Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'
2025-06-08 17:59:05,119 - VulnerabilityEngine - ERROR - Pass init 执行失败: ["Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'"]
2025-06-08 17:59:05,119 - VulnerabilityEngine - INFO - 分析完成，总耗时: 0.00秒
2025-06-08 17:59:05,120 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_175905.json
2025-06-08 18:00:05,581 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:00:10,622 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:00:10,675 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:00:10,675 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:00:10,675 - VulnerabilityEngine - INFO - 将执行 1 个分析passes: ['init']
2025-06-08 18:00:10,675 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:00:10,675 - VulnerabilityEngine - ERROR - Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'
2025-06-08 18:00:10,675 - VulnerabilityEngine - ERROR - Pass init 执行失败: ["Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'"]
2025-06-08 18:00:10,675 - VulnerabilityEngine - INFO - 分析完成，总耗时: 0.00秒
2025-06-08 18:00:10,676 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_180010.json
2025-06-08 18:00:36,766 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:00:41,689 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 将执行 1 个分析passes: ['init']
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:00:41,728 - VulnerabilityEngine - ERROR - Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'
2025-06-08 18:00:41,728 - VulnerabilityEngine - ERROR - Pass init 执行失败: ["Pass init 执行失败: 'str' object has no attribute 'joern_wrapper'"]
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 分析完成，总耗时: 0.00秒
2025-06-08 18:00:41,728 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_180041.json
2025-06-08 18:02:20,872 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:02:25,731 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:02:25,770 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:02:25,770 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:02:25,771 - VulnerabilityEngine - INFO - 将执行 1 个分析passes: ['init']
2025-06-08 18:02:25,771 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:02:25,771 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 18:02:26,402 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>io.joern.console.Error: No CPG loaded for project test1.c - try e.g. `help|importCode|importCpg|open`
=~...
2025-06-08 18:02:26,403 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - WARNING - 未能获取函数名列表
2025-06-08 18:02:26,403 - CPGvulnHunter.passes.initPass.InitPass - WARNING - No external functions to analyze.
2025-06-08 18:02:26,403 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 0.63秒
2025-06-08 18:02:26,403 - VulnerabilityEngine - INFO - 分析完成，总耗时: 0.63秒
2025-06-08 18:02:26,404 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_180226.json
2025-06-08 18:07:23,227 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:07:28,090 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:07:28,145 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:07:28,145 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 18:07:30,469 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test11` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/...
2025-06-08 18:07:30,470 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:07:30,470 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:07:30,470 - VulnerabilityEngine - INFO - 将执行 1 个分析passes: ['init']
2025-06-08 18:07:30,470 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:07:30,470 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 18:07:31,130 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
 ...
2025-06-08 18:07:31,131 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 18:07:31,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(ch...
2025-06-08 18:07:31,556 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 18:07:31,556 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 18:07:31,945 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astP...
2025-06-08 18:07:31,945 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 18:07:31,945 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 18:07:32,340 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "...
2025-06-08 18:07:32,340 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 18:07:32,340 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 18:07:32,739 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentT...
2025-06-08 18:07:32,740 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 18:07:32,740 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 18:07:33,120 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType"...
2025-06-08 18:07:33,121 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 18:07:33,121 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 18:07:33,484 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
 ...
2025-06-08 18:07:33,484 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 18:07:33,484 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 18:07:33,840 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESP...
2025-06-08 18:07:33,840 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 18:07:34,214 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VA...
2025-06-08 18:07:34,625 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:07:34,625 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 18:07:34,962 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":...
2025-06-08 18:07:34,962 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 18:07:35,342 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "a...
2025-06-08 18:07:35,342 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 18:07:35,666 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPA...
2025-06-08 18:07:35,667 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 18:07:36,011 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VA...
2025-06-08 18:07:36,380 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 18:07:36,381 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 18:07:36,683 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAM...
2025-06-08 18:07:36,684 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 18:07:36,990 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_...
2025-06-08 18:07:37,313 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:07:37,313 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 18:07:37,617 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature...
2025-06-08 18:07:37,618 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 18:07:37,951 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    ...
2025-06-08 18:07:37,952 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 18:07:37,952 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 18:07:37,952 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:07:37,953 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:07:38,134 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-5c97c93c-6509-450c-8032-5d412e038cd9', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:07:38,137 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:07:38,138 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 18:07:38,139 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x79f2541be840>
2025-06-08 18:07:38,139 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:07:38,140 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:07:38,140 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:07:38,140 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:07:38,140 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:08:22,776 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:07:37 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1080'), (b'content-type', b'application/json'), (b'x-process-time', b'44')])
2025-06-08 18:08:22,777 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:08:22,777 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:08:22,777 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:08:22,778 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:08:22,778 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:08:22,778 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:07:37 GMT', 'server': 'uvicorn', 'content-length': '1080', 'content-type': 'application/json', 'x-process-time': '44'})
2025-06-08 18:08:22,778 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:08:22,780 - root - DEBUG - 正在提取JSON，原始文本长度: 264, 清理后长度: 264
2025-06-08 18:08:22,780 - root - DEBUG - 直接解析成功
2025-06-08 18:08:22,780 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 添加语义规则，参数流数量: 1
2025-06-08 18:08:22,780 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 18:08:22,781 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:08:22,781 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:08:22,782 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d06c6c93-d1d8-454a-920c-cf54a8c87134', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:08:22,782 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:08:22,782 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:08:22,783 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:08:22,783 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:08:22,783 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:08:22,783 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:08:33,294 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:08:22 GMT'), (b'server', b'uvicorn'), (b'content-length', b'980'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 18:08:33,295 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:08:33,295 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:08:33,295 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:08:33,296 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:08:33,296 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:08:33,296 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:08:22 GMT', 'server': 'uvicorn', 'content-length': '980', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 18:08:33,296 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:08:33,297 - root - DEBUG - 正在提取JSON，原始文本长度: 234, 清理后长度: 234
2025-06-08 18:08:33,297 - root - DEBUG - 直接解析成功
2025-06-08 18:08:33,297 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 添加语义规则，参数流数量: 1
2025-06-08 18:08:33,297 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 18:08:33,297 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:08:33,297 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:08:33,299 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-6fdc7219-d192-4d58-b6f0-de1e5d61193d', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:08:33,299 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:08:33,300 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:08:33,300 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:08:33,300 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:08:33,300 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:08:33,300 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:08:44,111 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:08:32 GMT'), (b'server', b'uvicorn'), (b'content-length', b'969'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 18:08:44,111 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:08:44,111 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:08:44,112 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:08:44,112 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:08:44,112 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:08:44,112 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:08:32 GMT', 'server': 'uvicorn', 'content-length': '969', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 18:08:44,112 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:08:44,113 - root - DEBUG - 正在提取JSON，原始文本长度: 229, 清理后长度: 229
2025-06-08 18:08:44,113 - root - DEBUG - 直接解析成功
2025-06-08 18:08:44,113 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 添加语义规则，参数流数量: 1
2025-06-08 18:08:44,113 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成，总共生成 3 条语义规则
2025-06-08 18:08:44,113 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 18:08:44,426 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 18:08:44,736 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 18:08:44,736 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 18:08:45,013 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 18:08:45,013 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 18:08:45,282 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 18:08:45,282 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("...
2025-06-08 18:08:45,733 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), reg...
2025-06-08 18:08:45,733 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 18:08:46,021 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemant...
2025-06-08 18:08:46,021 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(maxCallDepth = 40, semantics = semantics)...
2025-06-08 18:08:46,375 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(maxCallDepth = 40, se
emantics = semantics)
>-- Error: ----------------------------------------------------------------------
1 |implicit val contex...
2025-06-08 18:08:46,375 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 18:08:46,375 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 18:08:46,375 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 75.91秒
2025-06-08 18:08:46,376 - VulnerabilityEngine - INFO - 分析完成，总耗时: 75.91秒
2025-06-08 18:08:46,377 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_180846.json
2025-06-08 18:15:19,100 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:15:19,100 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:15:19,101 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 18:15:19,101 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 18:15:19,101 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 18:15:19,101 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:15:23,957 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:15:23,957 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 18:15:23,957 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 18:15:24,008 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 18:15:24,008 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 18:15:24,008 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:15:24,008 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 18:15:26,255 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test12` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test12/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test12/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 18:15:26,255 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.25秒
2025-06-08 18:15:26,255 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 18:15:26,255 - VulnerabilityEngine - INFO - 引擎初始化完成 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:15:26,255 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:15:26,255 - VulnerabilityEngine - INFO - 将执行 1 个分析passes: ['init']
2025-06-08 18:15:26,255 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:15:26,255 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 18:15:26,890 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 18:15:26,891 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 18:15:27,286 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:15:27,287 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 18:15:27,287 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 18:15:27,701 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:15:27,701 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 18:15:27,701 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 18:15:28,084 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:15:28,084 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 18:15:28,085 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 18:15:28,438 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:15:28,439 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 18:15:28,439 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 18:15:28,810 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:15:28,811 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 18:15:28,811 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 18:15:29,162 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 18:15:29,163 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 18:15:29,163 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 18:15:29,519 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:29,520 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 18:15:29,865 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 18:15:30,249 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:15:30,249 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 18:15:30,588 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:30,588 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 18:15:30,930 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:30,931 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 18:15:31,243 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:31,243 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 18:15:31,576 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 18:15:31,932 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 18:15:31,932 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 18:15:32,262 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:32,263 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 18:15:32,607 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 18:15:32,956 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:15:32,956 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 18:15:33,266 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:33,267 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 18:15:33,621 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:15:33,621 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 18:15:33,621 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 18:15:33,622 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:15:33,622 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:15:33,808 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-3e7e75f1-735f-43e2-b4d4-f65d2fa7da87', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:15:33,811 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:15:33,811 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 18:15:33,813 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x752c9927a600>
2025-06-08 18:15:33,813 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:15:33,813 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:15:33,813 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:15:33,813 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:15:33,813 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:16:17,988 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:15:32 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1053'), (b'content-type', b'application/json'), (b'x-process-time', b'45')])
2025-06-08 18:16:17,989 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:16:17,989 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:16:17,989 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:16:17,989 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:16:17,990 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:16:17,990 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:15:32 GMT', 'server': 'uvicorn', 'content-length': '1053', 'content-type': 'application/json', 'x-process-time': '45'})
2025-06-08 18:16:17,990 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:16:17,993 - root - DEBUG - 正在提取JSON，原始文本长度: 255, 清理后长度: 255
2025-06-08 18:16:17,993 - root - DEBUG - 直接解析成功
2025-06-08 18:16:17,993 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 添加语义规则，参数流数量: 1
2025-06-08 18:16:17,993 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 18:16:17,993 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:16:17,993 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:16:17,994 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-f71fe919-2f5a-4bd1-b48e-4351e994f402', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:16:17,995 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:16:17,995 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:16:17,996 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:16:17,996 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:16:17,996 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:16:17,996 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:16:27,866 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:16:17 GMT'), (b'server', b'uvicorn'), (b'content-length', b'943'), (b'content-type', b'application/json'), (b'x-process-time', b'9')])
2025-06-08 18:16:27,866 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:16:27,867 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:16:27,867 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:16:27,867 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:16:27,867 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:16:27,867 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:16:17 GMT', 'server': 'uvicorn', 'content-length': '943', 'content-type': 'application/json', 'x-process-time': '9'})
2025-06-08 18:16:27,867 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:16:27,868 - root - DEBUG - 正在提取JSON，原始文本长度: 215, 清理后长度: 215
2025-06-08 18:16:27,868 - root - DEBUG - 直接解析成功
2025-06-08 18:16:27,869 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 添加语义规则，参数流数量: 1
2025-06-08 18:16:27,869 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 18:16:27,869 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:16:27,869 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:16:27,870 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-8a2c6c75-84b7-4027-b494-565b6da9f6cc', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:16:27,871 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:16:27,871 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:16:27,872 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:16:27,872 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:16:27,872 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:16:27,872 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:16:39,340 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:16:27 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1013'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-08 18:16:39,341 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:16:39,341 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:16:39,341 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:16:39,342 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:16:39,342 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:16:39,342 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:16:27 GMT', 'server': 'uvicorn', 'content-length': '1013', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-08 18:16:39,342 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:16:39,343 - root - DEBUG - 正在提取JSON，原始文本长度: 244, 清理后长度: 244
2025-06-08 18:16:39,343 - root - DEBUG - 直接解析成功
2025-06-08 18:16:39,343 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 添加语义规则，参数流数量: 1
2025-06-08 18:16:39,343 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成，总共生成 3 条语义规则
2025-06-08 18:16:39,343 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 18:16:39,694 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 18:16:39,980 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 18:16:39,980 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 18:16:40,269 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 18:16:40,270 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 18:16:40,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 18:16:40,556 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 18:16:41,022 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 18:16:41,023 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 18:16:41,325 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@70685cad
=~...
2025-06-08 18:16:41,326 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(maxCallDepth = 40, semantics = semantics)...
2025-06-08 18:16:41,685 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(maxCallDepth = 40, se
emantics = semantics)
>-- Error: ----------------------------------------------------------------------
1 |implicit val context: EngineContext = EngineContext(maxCallDepth = 40, semantics = semantics)
  |                                                    ^^^^^^^^^^^^^^^^^
  |method apply in object EngineContext: (semantics: io.joern.dataflowengineoss.semanticsloader.Semantics, config:
  |  io.joern.dataflowengineoss.queryengine.EngineConfig):
  |  io.joern.dataflowengineoss.queryengine.EngineContext does not have a parameter maxCallDepth
1 error found
=~...
2025-06-08 18:16:41,685 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 18:16:41,686 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 18:16:41,686 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 75.43秒
2025-06-08 18:16:41,686 - VulnerabilityEngine - INFO - 分析完成，总耗时: 75.43秒
2025-06-08 18:16:41,687 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_181641.json
2025-06-08 18:26:07,211 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:26:07,211 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 18:26:07,211 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 18:26:07,211 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 18:26:07,211 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 18:26:07,211 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 18:26:07,211 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 18:26:07,211 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:26:07,212 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:26:07,212 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 18:26:07,212 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 18:26:07,212 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 18:26:07,212 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 18:26:12,202 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 18:26:12,202 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 18:26:12,202 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 18:26:12,202 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 18:26:12,202 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 18:26:12,246 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-08 18:26:12,246 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 18:26:12,246 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 18:26:12,246 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 18:26:12,246 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 18:26:12,246 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 18:26:14,657 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test13` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test13/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test13/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 18:26:14,657 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.41秒
2025-06-08 18:26:14,658 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.45秒
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 18:26:14,658 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 18:26:14,659 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 18:26:14,659 - VulnerabilityEngine - INFO -   - 启用的passes: ['init'] (共 1 个)
2025-06-08 18:26:14,660 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 18:26:14,660 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 18:26:14,660 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 18:26:14,660 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/1: init ---
2025-06-08 18:26:14,660 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 18:26:14,660 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 18:26:15,297 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 18:26:15,297 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 18:26:15,727 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:26:15,728 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 18:26:15,728 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 18:26:16,125 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:26:16,125 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 18:26:16,125 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 18:26:16,496 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:26:16,497 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 18:26:16,497 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 18:26:16,882 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:26:16,883 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 18:26:16,883 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 18:26:17,248 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 18:26:17,248 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 18:26:17,248 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 18:26:17,605 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 18:26:17,606 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 18:26:17,606 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 18:26:17,945 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:17,945 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 18:26:18,296 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 18:26:18,714 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:26:18,714 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 18:26:19,007 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:19,007 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 18:26:19,282 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:19,282 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 18:26:19,557 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:19,557 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 18:26:19,838 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 18:26:20,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 18:26:20,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 18:26:20,498 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:20,499 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 18:26:20,854 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 18:26:21,205 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 18:26:21,205 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 18:26:21,527 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:21,527 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 18:26:21,872 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 18:26:21,872 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 18:26:21,872 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 18:26:21,873 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 18:26:21,873 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 18:26:21,873 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:26:21,873 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:26:22,055 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-4fe26a4e-e4a8-424e-961b-8b4827b1760f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:26:22,058 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:26:22,059 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 18:26:22,060 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x76f3c7336510>
2025-06-08 18:26:22,060 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:26:22,061 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:26:22,061 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:26:22,061 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:26:22,061 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:27:05,666 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:26:21 GMT'), (b'server', b'uvicorn'), (b'content-length', b'986'), (b'content-type', b'application/json'), (b'x-process-time', b'43')])
2025-06-08 18:27:05,667 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:27:05,667 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:27:05,667 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:27:05,667 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:27:05,667 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:27:05,668 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:26:21 GMT', 'server': 'uvicorn', 'content-length': '986', 'content-type': 'application/json', 'x-process-time': '43'})
2025-06-08 18:27:05,668 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:27:05,670 - root - DEBUG - 正在提取JSON，原始文本长度: 233, 清理后长度: 233
2025-06-08 18:27:05,670 - root - DEBUG - 直接解析成功
2025-06-08 18:27:05,670 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 43.80秒
2025-06-08 18:27:05,670 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 18:27:05,670 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 18:27:05,670 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 18:27:05,670 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: 根据函数调用示例，printf从第二个参数（格式化字符串后的实际数据）流向输出。
2025-06-08 18:27:05,671 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 43.80秒
2025-06-08 18:27:05,671 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 18:27:05,671 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 18:27:05,671 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 18:27:05,671 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:27:05,671 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:27:05,672 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-10662e3c-6880-476b-93b7-12808eb59fad', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:27:05,672 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:27:05,673 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:27:05,673 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:27:05,673 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:27:05,673 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:27:05,673 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:27:15,886 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:27:05 GMT'), (b'server', b'uvicorn'), (b'content-length', b'959'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 18:27:15,887 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:27:15,887 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:27:15,887 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:27:15,887 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:27:15,887 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:27:15,888 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:27:05 GMT', 'server': 'uvicorn', 'content-length': '959', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 18:27:15,888 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:27:15,888 - root - DEBUG - 正在提取JSON，原始文本长度: 221, 清理后长度: 221
2025-06-08 18:27:15,889 - root - DEBUG - 直接解析成功
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 10.22秒
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 根据函数签名和用法，数据从参数3（流）流向参数1（缓冲区）。
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 10.22秒
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 18:27:15,889 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 18:27:15,889 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 18:27:15,890 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 18:27:15,891 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-b8357e25-7a00-4c75-9864-b1e46bd1c2f6', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 18:27:15,891 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 18:27:15,892 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 18:27:15,892 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 18:27:15,892 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 18:27:15,892 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 18:27:15,892 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 18:27:26,528 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 10:27:15 GMT'), (b'server', b'uvicorn'), (b'content-length', b'930'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 18:27:26,529 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 18:27:26,529 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 18:27:26,529 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 18:27:26,529 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 18:27:26,529 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 18:27:26,530 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 10:27:15 GMT', 'server': 'uvicorn', 'content-length': '930', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 18:27:26,530 - openai._base_client - DEBUG - request_id: None
2025-06-08 18:27:26,531 - root - DEBUG - 正在提取JSON，原始文本长度: 216, 清理后长度: 216
2025-06-08 18:27:26,531 - root - DEBUG - 直接解析成功
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 10.64秒
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 函数strncpy从源字符串参数流向目标缓冲区
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 10.64秒
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 64.66秒
2025-06-08 18:27:26,531 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 18:27:26,532 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 18:27:26,847 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 18:27:27,132 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 18:27:27,133 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 18:27:27,443 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 18:27:27,443 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 18:27:27,732 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 18:27:27,732 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 18:27:28,237 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 18:27:28,238 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 18:27:28,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@50d8c98c
=~...
2025-06-08 18:27:28,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 18:27:28,842 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@50d8c98c,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 18:27:28,843 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 18:27:28,843 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 18:27:28,843 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 74.18秒
2025-06-08 18:27:28,843 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 18:27:28,843 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 18:27:28,843 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 总耗时: 74.18秒
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 执行的passes: 1/1
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 成功的passes: 1
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO -   - init: 成功 (74.18s, 0个发现)
2025-06-08 18:27:28,844 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 18:27:28,846 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_182728.json
2025-06-08 20:51:54,371 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:51:54,371 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 20:51:54,371 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 20:51:54,371 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 20:51:54,371 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 20:51:54,371 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 20:51:54,371 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 20:51:54,371 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:51:54,371 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:51:54,372 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 20:51:54,372 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 20:51:54,372 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 20:51:54,372 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 20:51:59,203 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 20:51:59,204 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 20:51:59,204 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 20:51:59,204 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 20:51:59,204 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 20:51:59,271 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.07秒
2025-06-08 20:51:59,271 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 20:51:59,271 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 20:51:59,271 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 20:51:59,271 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:51:59,271 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 20:52:01,567 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test14` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test14/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test14/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 20:52:01,567 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.30秒
2025-06-08 20:52:01,567 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.20秒
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 20:52:01,567 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 20:52:01,940 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 已关闭
2025-06-08 20:54:10,204 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:54:10,204 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 20:54:10,204 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 20:54:10,204 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 20:54:10,204 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 20:54:10,204 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 20:54:10,204 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 20:54:10,204 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:54:10,204 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:54:10,205 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 20:54:10,205 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 20:54:10,205 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 20:54:10,205 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 20:54:15,111 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 20:54:15,111 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 20:54:15,112 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 20:54:15,112 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 20:54:15,112 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 20:54:15,157 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.05秒
2025-06-08 20:54:15,157 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 20:54:15,157 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 20:54:15,157 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 20:54:15,157 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 20:54:15,157 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 20:54:17,500 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test15` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test15/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test15/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 20:54:17,500 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.34秒
2025-06-08 20:54:17,501 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.30秒
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 20:54:17,501 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 20:54:17,502 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 20:54:17,502 - VulnerabilityEngine - INFO -   - 启用的passes: ['init'] (共 1 个)
2025-06-08 20:54:17,503 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 20:54:17,503 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 20:54:17,503 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 20:54:17,503 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/1: init ---
2025-06-08 20:54:17,503 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 20:54:17,503 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 20:54:18,155 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 20:54:18,155 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 20:54:18,583 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 20:54:18,584 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 20:54:18,584 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 20:54:18,960 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 20:54:18,960 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 20:54:18,961 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 20:54:19,320 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 20:54:19,321 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 20:54:19,321 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 20:54:19,694 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 20:54:19,694 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 20:54:19,694 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 20:54:20,043 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 20:54:20,043 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 20:54:20,043 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 20:54:20,408 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 20:54:20,408 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 20:54:20,408 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 20:54:20,761 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:20,762 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 20:54:21,110 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 20:54:21,512 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 20:54:21,513 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 20:54:21,856 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:21,856 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 20:54:22,192 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:22,193 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 20:54:22,524 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:22,524 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 20:54:22,864 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 20:54:23,227 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 20:54:23,228 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 20:54:23,513 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:23,513 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 20:54:23,820 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 20:54:24,180 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 20:54:24,180 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 20:54:24,491 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:24,491 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 20:54:24,829 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 20:54:24,830 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 20:54:24,830 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 20:54:24,830 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 20:54:24,830 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 20:54:24,830 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 20:54:24,831 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 20:54:25,017 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-6ee5cf04-4e2e-4ac7-b0fd-ed55c44f4f84', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 20:54:25,019 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 20:54:25,020 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 20:54:25,021 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7909a581e750>
2025-06-08 20:54:25,021 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 20:54:25,022 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 20:54:25,022 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 20:54:25,022 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 20:54:25,022 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 20:55:08,918 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 12:54:24 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1000'), (b'content-type', b'application/json'), (b'x-process-time', b'43')])
2025-06-08 20:55:08,919 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 20:55:08,919 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 20:55:08,920 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 20:55:08,920 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 20:55:08,920 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 20:55:08,920 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 12:54:24 GMT', 'server': 'uvicorn', 'content-length': '1000', 'content-type': 'application/json', 'x-process-time': '43'})
2025-06-08 20:55:08,920 - openai._base_client - DEBUG - request_id: None
2025-06-08 20:55:08,922 - root - DEBUG - 正在提取JSON，原始文本长度: 238, 清理后长度: 238
2025-06-08 20:55:08,922 - root - DEBUG - 直接解析成功
2025-06-08 20:55:08,922 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 44.09秒
2025-06-08 20:55:08,922 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 20:55:08,922 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 20:55:08,922 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 20:55:08,923 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数从格式字符串后的参数获取数据并输出，第2个及之后的参数流向返回值或外部输出
2025-06-08 20:55:08,923 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 44.09秒
2025-06-08 20:55:08,923 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 20:55:08,923 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 20:55:08,923 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 20:55:08,923 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 20:55:08,923 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 20:55:08,924 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-718f18b8-17bc-477f-833a-c9af7d12523e', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 20:55:08,924 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 20:55:08,925 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 20:55:08,925 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 20:55:08,925 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 20:55:08,925 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 20:55:08,925 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 20:55:18,720 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 12:55:07 GMT'), (b'server', b'uvicorn'), (b'content-length', b'922'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 20:55:18,720 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 20:55:18,720 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 20:55:18,720 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 20:55:18,720 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 20:55:18,721 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 20:55:18,721 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 12:55:07 GMT', 'server': 'uvicorn', 'content-length': '922', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 20:55:18,721 - openai._base_client - DEBUG - request_id: None
2025-06-08 20:55:18,721 - root - DEBUG - 正在提取JSON，原始文本长度: 212, 清理后长度: 212
2025-06-08 20:55:18,721 - root - DEBUG - 直接解析成功
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.80秒
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 数据从文件流(参数3)流向缓冲区(参数1)
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.80秒
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 20:55:18,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 20:55:18,722 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 20:55:18,722 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 20:55:18,723 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-04e08116-5c77-4087-8138-42f0a5052907', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 20:55:18,724 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 20:55:18,724 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 20:55:18,724 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 20:55:18,724 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 20:55:18,724 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 20:55:18,725 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 20:55:29,262 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 12:55:17 GMT'), (b'server', b'uvicorn'), (b'content-length', b'939'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 20:55:29,262 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 20:55:29,262 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 20:55:29,263 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 20:55:29,263 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 20:55:29,263 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 20:55:29,263 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 12:55:17 GMT', 'server': 'uvicorn', 'content-length': '939', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 20:55:29,263 - openai._base_client - DEBUG - request_id: None
2025-06-08 20:55:29,264 - root - DEBUG - 正在提取JSON，原始文本长度: 219, 清理后长度: 219
2025-06-08 20:55:29,264 - root - DEBUG - 直接解析成功
2025-06-08 20:55:29,264 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 10.54秒
2025-06-08 20:55:29,264 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 20:55:29,264 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 20:55:29,264 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 20:55:29,264 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: strncpy函数从源字符串参数传递数据到目标缓冲区
2025-06-08 20:55:29,265 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 10.54秒
2025-06-08 20:55:29,265 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 64.44秒
2025-06-08 20:55:29,265 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 20:55:29,265 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 20:55:29,586 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 20:55:29,900 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 20:55:29,900 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 20:55:30,183 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 20:55:30,184 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 20:55:30,468 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 20:55:30,468 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 20:55:30,943 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 20:55:30,943 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 20:55:31,240 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@518b3e15
=~...
2025-06-08 20:55:31,240 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 20:55:31,553 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@518b3e15,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 20:55:31,553 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 20:55:31,554 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 74.05秒
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 20:55:31,554 - VulnerabilityEngine - INFO - 总耗时: 74.05秒
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO - 执行的passes: 1/1
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO - 成功的passes: 1
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO -   - init: 成功 (74.05s, 0个发现)
2025-06-08 20:55:31,555 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 20:55:31,556 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_205531.json
2025-06-08 21:09:39,504 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:09:39,505 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:09:39,505 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:09:39,505 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:09:39,505 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:09:39,505 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:09:39,505 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:09:39,505 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:09:39,505 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:09:39,505 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:09:39,505 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:09:39,505 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:09:39,505 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:09:44,499 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:09:44,500 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:09:44,500 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:09:44,500 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:09:44,500 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:09:44,564 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.06秒
2025-06-08 21:09:44,564 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:09:44,564 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:09:44,564 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:09:44,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:09:44,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:09:46,801 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test16` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test16/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test16/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:09:46,802 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.24秒
2025-06-08 21:09:46,802 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.30秒
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:09:46,803 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:09:46,804 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:09:46,804 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:09:46,804 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:09:46,805 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:09:46,805 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:09:46,805 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:09:46,805 - VulnerabilityEngine - INFO -   - 启用的passes: ['init'] (共 1 个)
2025-06-08 21:09:46,805 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:09:46,806 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:09:46,806 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:09:46,806 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/1: init ---
2025-06-08 21:09:46,806 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:09:46,806 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:09:47,458 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:09:47,458 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:09:47,855 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:09:47,856 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:09:47,856 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:09:48,232 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:09:48,233 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:09:48,233 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:09:48,606 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:09:48,606 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:09:48,606 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:09:48,959 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:09:48,959 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:09:48,960 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:09:49,316 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:09:49,317 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:09:49,317 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:09:49,675 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:09:49,676 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:09:49,676 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:09:50,017 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:50,017 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:09:50,387 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:09:50,777 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:09:50,777 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:09:51,135 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:51,135 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:09:51,485 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:51,486 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:09:51,801 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:51,801 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:09:52,143 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:09:52,483 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:09:52,484 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:09:52,801 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:52,802 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:09:53,137 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:09:53,496 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:09:53,497 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:09:53,812 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:53,813 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:09:54,145 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:09:54,146 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:09:54,146 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:09:54,146 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:09:54,146 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:09:54,147 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:09:54,147 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:09:54,335 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-42b2bf0a-d7be-47bf-a440-16da89bb6a77', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:09:54,338 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:09:54,338 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:09:54,340 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7749f1726a50>
2025-06-08 21:09:54,340 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:09:54,340 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:09:54,340 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:09:54,340 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:09:54,340 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:10:38,227 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:09:54 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1013'), (b'content-type', b'application/json'), (b'x-process-time', b'44')])
2025-06-08 21:10:38,228 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:10:38,228 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:10:38,229 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:10:38,229 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:10:38,229 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:10:38,229 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:09:54 GMT', 'server': 'uvicorn', 'content-length': '1013', 'content-type': 'application/json', 'x-process-time': '44'})
2025-06-08 21:10:38,229 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:10:38,231 - root - DEBUG - 正在提取JSON，原始文本长度: 242, 清理后长度: 242
2025-06-08 21:10:38,231 - root - DEBUG - 直接解析成功
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 44.08秒
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数从第二个参数（格式化字符串后的数据）流向输出，这里的数据流是从格式化的参数到输出。
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 44.09秒
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:10:38,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:10:38,231 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:10:38,232 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:10:38,232 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-962a353b-086c-4827-9e01-a84b7d19737e', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:10:38,233 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:10:38,233 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:10:38,233 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:10:38,233 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:10:38,233 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:10:38,233 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:10:48,131 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:10:37 GMT'), (b'server', b'uvicorn'), (b'content-length', b'943'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 21:10:48,132 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:10:48,132 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:10:48,132 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:10:48,132 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:10:48,132 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:10:48,132 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:10:37 GMT', 'server': 'uvicorn', 'content-length': '943', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 21:10:48,132 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:10:48,133 - root - DEBUG - 正在提取JSON，原始文本长度: 215, 清理后长度: 215
2025-06-08 21:10:48,133 - root - DEBUG - 直接解析成功
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.90秒
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 根据函数签名和使用示例，数据从输入流流向缓冲区。
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.90秒
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:10:48,133 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:10:48,134 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:10:48,134 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:10:48,134 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-be0a8f45-456c-4431-a1d0-6d798e13f4b6', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:10:48,135 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:10:48,135 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:10:48,136 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:10:48,136 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:10:48,136 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:10:48,136 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:10:59,376 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:10:47 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1000'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:10:59,377 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:10:59,377 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:10:59,377 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:10:59,377 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:10:59,377 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:10:59,377 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:10:47 GMT', 'server': 'uvicorn', 'content-length': '1000', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:10:59,378 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:10:59,378 - root - DEBUG - 正在提取JSON，原始文本长度: 240, 清理后长度: 240
2025-06-08 21:10:59,378 - root - DEBUG - 直接解析成功
2025-06-08 21:10:59,378 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.24秒
2025-06-08 21:10:59,378 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 数据从第2个参数（源字符串）流向第1个参数（目标缓冲区），这是strcpy家族函数的标准行为。
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.25秒
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 65.23秒
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:10:59,379 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:10:59,689 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:10:59,966 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:10:59,966 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:11:00,245 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:11:00,245 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:11:00,517 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:11:00,517 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:11:00,905 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:11:00,905 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:11:01,187 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@407c974c
=~...
2025-06-08 21:11:01,187 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:11:01,476 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@407c974c,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:11:01,477 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:11:01,477 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 74.67秒
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:11:01,477 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 总耗时: 74.67秒
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 执行的passes: 1/1
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 成功的passes: 1
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO -   - init: 成功 (74.67s, 0个发现)
2025-06-08 21:11:01,478 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:11:01,479 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_211101.json
2025-06-08 21:12:09,116 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:09,117 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:09,117 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:09,117 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:09,117 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:09,117 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:09,117 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:09,117 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:09,117 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:09,119 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:09,119 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:09,119 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:09,119 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:10,142 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,143 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:10,143 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:10,143 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:10,143 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:10,143 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:10,143 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:10,143 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,143 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,144 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:10,144 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:10,145 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:10,145 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:10,435 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,436 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:10,436 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:10,436 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:10,436 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:10,436 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:10,436 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:10,437 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,437 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,438 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:10,438 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:10,438 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:10,439 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:10,447 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,447 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:10,447 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:10,447 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:10,447 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:10,448 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:10,448 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:10,448 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,448 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,449 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:10,449 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:10,449 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:10,450 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:10,803 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,804 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:10,804 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:10,804 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:10,804 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:10,804 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:10,804 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:10,805 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,805 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:10,806 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:10,806 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:10,806 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:10,807 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:12,463 - CPGvulnHunter.bridges.joernBridge.JoernBridge - WARNING - 启动尝试 1 失败: Joern 进程启动后立即退出
2025-06-08 21:12:12,722 - CPGvulnHunter.bridges.joernBridge.JoernBridge - WARNING - 启动尝试 1 失败: Joern 进程启动后立即退出
2025-06-08 21:12:12,871 - CPGvulnHunter.bridges.joernBridge.JoernBridge - WARNING - 启动尝试 1 失败: Joern 进程启动后立即退出
2025-06-08 21:12:13,145 - CPGvulnHunter.bridges.joernBridge.JoernBridge - WARNING - 启动尝试 1 失败: Joern 进程启动后立即退出
2025-06-08 21:12:27,709 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:27,709 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:12:27,709 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init']
2025-06-08 21:12:27,709 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:12:27,709 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:12:27,710 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:12:27,710 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:12:27,710 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:27,710 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:27,711 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:12:27,711 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:12:27,711 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:12:27,712 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:12:37,575 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:12:37,576 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:12:37,576 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:12:37,576 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:12:37,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:12:37,700 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.12秒
2025-06-08 21:12:37,700 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:12:37,700 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:12:37,700 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:12:37,700 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:12:37,700 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:12:40,081 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test17` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test17/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test17/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:12:40,081 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.38秒
2025-06-08 21:12:40,081 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 12.37秒
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:12:40,082 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:13:07,018 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:13:07,546 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:13:23,648 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:13:24,291 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:13:24,879 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:15:57,635 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:15:57,635 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:15:57,635 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:15:57,635 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:15:57,635 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:15:57,635 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:15:57,635 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:15:57,635 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:15:57,635 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:15:57,635 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:15:57,635 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:15:57,635 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:15:57,636 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:16:02,557 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:16:02,557 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:16:02,557 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:16:02,557 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:16:02,557 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:16:02,596 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-08 21:16:02,596 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:16:02,597 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:16:02,597 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:16:02,597 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:16:02,597 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:16:04,930 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test18` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test18/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test18/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:16:04,931 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.33秒
2025-06-08 21:16:04,931 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:16:04,931 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.30秒
2025-06-08 21:16:04,931 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:16:04,932 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:16:04,932 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:16:04,932 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:16:04,932 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:16:04,933 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:16:04,933 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:16:04,933 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:16:04,933 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:16:04,934 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:16:04,935 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:16:04,935 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:16:04,935 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:16:05,519 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:16:05,520 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:16:05,933 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:16:05,934 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:16:05,934 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:16:06,320 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:16:06,321 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:16:06,321 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:16:06,658 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:16:06,659 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:16:06,659 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:16:06,944 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:16:06,944 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:16:06,944 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:16:07,261 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:16:07,261 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:16:07,261 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:16:07,621 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:16:07,622 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:16:07,622 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:16:07,968 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:07,969 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:16:08,330 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:16:08,737 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:16:08,738 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:16:09,073 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:09,074 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:16:09,410 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:09,411 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:16:09,733 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:09,733 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:16:10,077 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:16:10,433 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:16:10,433 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:16:10,753 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:10,753 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:16:11,108 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:16:11,468 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:16:11,469 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:16:11,773 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:11,773 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:16:12,106 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:16:12,107 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:16:12,107 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:16:12,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:16:12,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:16:12,107 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:16:12,108 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:16:12,298 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-462fe56e-9d18-4ac7-93c9-0238eaa36eb4', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:16:12,302 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:16:12,302 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:16:12,303 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7dd1a0ce6a50>
2025-06-08 21:16:12,303 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:16:12,304 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:16:12,304 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:16:12,304 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:16:12,304 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:16:56,974 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:16:11 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1071'), (b'content-type', b'application/json'), (b'x-process-time', b'44')])
2025-06-08 21:16:56,975 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:16:56,975 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:16:56,975 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:16:56,975 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:16:56,975 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:16:56,976 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:16:11 GMT', 'server': 'uvicorn', 'content-length': '1071', 'content-type': 'application/json', 'x-process-time': '44'})
2025-06-08 21:16:56,976 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:16:56,978 - root - DEBUG - 正在提取JSON，原始文本长度: 262, 清理后长度: 262
2025-06-08 21:16:56,978 - root - DEBUG - 直接解析成功
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 44.87秒
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数的格式化字符串和后续参数之间的数据流向标准输出。此处关注的是占位符与实际值的数据流动关系，从第2个参数开始的数据流向输出。
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 44.87秒
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:16:56,978 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:16:56,978 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:16:56,978 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:16:56,979 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-fb571a8b-8e68-41f2-ab47-00fd6c5a4b26', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:16:56,980 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:16:56,980 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:16:56,980 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:16:56,980 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:16:56,980 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:16:56,980 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:17:06,478 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:16:56 GMT'), (b'server', b'uvicorn'), (b'content-length', b'915'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 21:17:06,479 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:17:06,479 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:17:06,479 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:17:06,479 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:17:06,479 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:17:06,480 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:16:56 GMT', 'server': 'uvicorn', 'content-length': '915', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 21:17:06,480 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:17:06,480 - root - DEBUG - 正在提取JSON，原始文本长度: 209, 清理后长度: 209
2025-06-08 21:17:06,481 - root - DEBUG - 直接解析成功
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.50秒
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 函数fgets从流参数流向目标缓冲区
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.50秒
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:17:06,481 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:17:06,481 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:17:06,481 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:17:06,482 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-a3f9aa90-104f-45bd-8dc7-895ecb89004f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:17:06,483 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:17:06,483 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:17:06,483 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:17:06,484 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:17:06,484 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:17:06,484 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:17:17,520 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:17:05 GMT'), (b'server', b'uvicorn'), (b'content-length', b'979'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:17:17,520 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:17:17,521 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:17:17,521 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:17:17,521 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:17:17,521 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:17:17,521 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:17:05 GMT', 'server': 'uvicorn', 'content-length': '979', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:17:17,521 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:17:17,522 - root - DEBUG - 正在提取JSON，原始文本长度: 229, 清理后长度: 229
2025-06-08 21:17:17,522 - root - DEBUG - 直接解析成功
2025-06-08 21:17:17,522 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.04秒
2025-06-08 21:17:17,522 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:17:17,522 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:17:17,522 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:17:17,523 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 根据函数签名和用法，参数2（源字符串）的数据流向了参数1（目标缓冲区）。
2025-06-08 21:17:17,523 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.04秒
2025-06-08 21:17:17,523 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 65.42秒
2025-06-08 21:17:17,523 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:17:17,523 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:17:17,846 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:17:18,135 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:17:18,135 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:17:18,422 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:17:18,423 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:17:18,706 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:17:18,707 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:17:19,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:17:19,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:17:19,488 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@578a1c1a
=~...
2025-06-08 21:17:19,488 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:17:19,786 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@578a1c1a,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:17:19,786 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:17:19,787 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:17:19,787 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 74.85秒
2025-06-08 21:17:19,787 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:17:19,787 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:17:19,787 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-08 21:17:19,787 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-08 21:17:19,787 - VulnerabilityEngine - ERROR - Pass cwe78 执行失败: CWE78.__init__() missing 1 required positional argument: 'llmWrapper'
2025-06-08 21:17:19,788 - VulnerabilityEngine - ERROR - ✗ Pass cwe78 执行失败: ["Pass cwe78 执行失败: CWE78.__init__() missing 1 required positional argument: 'llmWrapper'"]
2025-06-08 21:17:19,788 - VulnerabilityEngine - WARNING - 非并行模式下遇到错误，停止后续pass执行
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - 总耗时: 74.85秒
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-08 21:17:19,788 - VulnerabilityEngine - INFO - 成功的passes: 1
2025-06-08 21:17:19,789 - VulnerabilityEngine - INFO - 失败的passes: 1
2025-06-08 21:17:19,789 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:17:19,789 - VulnerabilityEngine - INFO -   - init: 成功 (74.85s, 0个发现)
2025-06-08 21:17:19,789 - VulnerabilityEngine - INFO -   - cwe78: 失败 (0.00s, 0个发现)
2025-06-08 21:17:19,789 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:17:19,790 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_211719.json
2025-06-08 21:18:51,184 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:18:51,184 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:18:51,184 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:18:51,184 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:18:51,184 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:18:51,184 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:18:51,184 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:18:51,184 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:18:51,184 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:18:51,185 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:18:51,185 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:18:51,185 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:18:51,185 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:18:56,188 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:18:56,189 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:18:56,190 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:18:56,190 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:18:56,190 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:18:56,241 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.05秒
2025-06-08 21:18:56,241 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:18:56,241 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:18:56,241 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:18:56,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:18:56,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:18:58,624 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test19` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test19/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test19/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:18:58,625 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.38秒
2025-06-08 21:18:58,625 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:18:58,625 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.44秒
2025-06-08 21:18:58,625 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:18:58,626 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:18:58,626 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:18:58,626 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:18:58,626 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:18:58,626 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:18:58,626 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:18:58,627 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:18:58,628 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:18:58,628 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:18:59,240 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:18:59,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:18:59,659 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:18:59,659 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:18:59,659 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:19:00,052 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:19:00,053 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:19:00,053 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:19:00,446 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:19:00,447 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:19:00,447 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:19:00,829 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:19:00,830 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:19:00,830 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:19:01,210 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:19:01,211 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:19:01,211 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:19:01,600 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:19:01,600 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:19:01,600 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:19:01,947 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:01,947 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:19:02,312 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:19:02,703 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:19:02,704 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:19:03,059 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:03,059 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:19:03,409 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:03,410 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:19:03,750 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:03,750 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:19:04,085 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:19:04,423 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:19:04,423 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:19:04,764 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:04,764 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:19:05,113 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:19:05,476 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:19:05,476 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:19:05,790 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:05,791 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:19:06,140 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:19:06,141 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:19:06,141 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:19:06,141 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:19:06,141 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:19:06,141 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:19:06,142 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:19:06,333 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-8ceed226-50d5-4921-a994-df78e259378b', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:19:06,336 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:19:06,336 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:19:06,338 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7e6ee56d3110>
2025-06-08 21:19:06,338 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:19:06,338 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:19:06,338 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:19:06,338 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:19:06,338 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:19:17,895 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:19:06 GMT'), (b'server', b'uvicorn'), (b'content-length', b'988'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:19:17,896 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:19:17,897 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:19:17,897 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:19:17,897 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:19:17,897 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:19:17,897 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:19:06 GMT', 'server': 'uvicorn', 'content-length': '988', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:19:17,897 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:19:17,900 - root - DEBUG - 正在提取JSON，原始文本长度: 235, 清理后长度: 235
2025-06-08 21:19:17,900 - root - DEBUG - 直接解析成功
2025-06-08 21:19:17,900 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 11.76秒
2025-06-08 21:19:17,900 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:19:17,900 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: 根据函数使用示例，printf的第2个参数（格式化字符串后的实际数据）流向了输出流。
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 11.76秒
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:19:17,901 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:19:17,901 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:19:17,901 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:19:17,902 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-a88a3ebc-f3c9-4027-92b1-18abd17ec71f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:19:17,903 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:19:17,903 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:19:17,903 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:19:17,904 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:19:17,904 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:19:17,904 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:19:28,333 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:19:17 GMT'), (b'server', b'uvicorn'), (b'content-length', b'989'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:19:28,334 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:19:28,334 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:19:28,334 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:19:28,334 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:19:28,334 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:19:28,334 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:19:17 GMT', 'server': 'uvicorn', 'content-length': '989', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:19:28,335 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:19:28,335 - root - DEBUG - 正在提取JSON，原始文本长度: 231, 清理后长度: 231
2025-06-08 21:19:28,336 - root - DEBUG - 直接解析成功
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 10.43秒
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 函数从参数3（输入流）读取数据并存储到参数1（目标缓冲区），这是标准的数据流向。
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 10.44秒
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:19:28,336 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:19:28,336 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:19:28,337 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:19:28,338 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-7a6b37f6-706f-40d4-af54-fc0a95bdcdee', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:19:28,339 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:19:28,339 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:19:28,339 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:19:28,339 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:19:28,339 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:19:28,340 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:19:39,821 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:19:28 GMT'), (b'server', b'uvicorn'), (b'content-length', b'993'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:19:39,822 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:19:39,822 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:19:39,822 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:19:39,823 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:19:39,823 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:19:39,823 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:19:28 GMT', 'server': 'uvicorn', 'content-length': '993', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:19:39,823 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:19:39,824 - root - DEBUG - 正在提取JSON，原始文本长度: 241, 清理后长度: 241
2025-06-08 21:19:39,824 - root - DEBUG - 直接解析成功
2025-06-08 21:19:39,824 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.49秒
2025-06-08 21:19:39,824 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 根据函数签名和用法，strncpy从源字符串参数(索引为2)复制数据到目标缓冲区参数(索引为1)
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.49秒
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 33.68秒
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:19:39,825 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:19:40,150 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:19:40,439 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:19:40,440 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:19:40,729 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:19:40,729 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:19:41,028 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:19:41,028 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:19:41,479 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:19:41,479 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:19:41,772 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@407c974c
=~...
2025-06-08 21:19:41,772 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:19:42,067 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@407c974c,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:19:42,067 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:19:42,067 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:19:42,068 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 43.44秒
2025-06-08 21:19:42,068 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:19:42,068 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:19:42,068 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-08 21:19:42,068 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-08 21:19:42,068 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-08 21:19:42,068 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:19:42,069 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:19:42,069 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:19:42,071 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-e7bdb300-5298-4849-8fb3-5c86e9fd7c80', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:19:42,072 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:19:42,073 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:19:42,074 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:19:42,074 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:19:42,074 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:19:42,074 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:19:54,180 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:19:41 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1406'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-08 21:19:54,181 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:19:54,181 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:19:54,182 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:19:54,182 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:19:54,182 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:19:54,183 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:19:41 GMT', 'server': 'uvicorn', 'content-length': '1406', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-08 21:19:54,183 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:19:54,184 - root - DEBUG - 正在提取JSON，原始文本长度: 437, 清理后长度: 437
2025-06-08 21:19:54,185 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-08 21:19:54,185 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:19:54,185 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 12.12秒
2025-06-08 21:19:54,186 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:19:54,186 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:19:54,186 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:19:54,186 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:19:54,188 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-70abb24f-cb25-494c-8888-2003b0706d89', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:19:54,190 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:19:54,190 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:19:54,191 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:19:54,191 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:19:54,191 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:19:54,192 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:20:10,708 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:19:54 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1899'), (b'content-type', b'application/json'), (b'x-process-time', b'16')])
2025-06-08 21:20:10,709 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:20:10,709 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:20:10,710 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:20:10,710 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:20:10,710 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:20:10,710 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:19:54 GMT', 'server': 'uvicorn', 'content-length': '1899', 'content-type': 'application/json', 'x-process-time': '16'})
2025-06-08 21:20:10,710 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:20:10,712 - root - DEBUG - 正在提取JSON，原始文本长度: 702, 清理后长度: 702
2025-06-08 21:20:10,712 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:20:10,712 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 295)
2025-06-08 21:20:10,713 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:20:10,713 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 295)
2025-06-08 21:20:10,714 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
 ...
2025-06-08 21:20:10,716 - root - ERROR - 无法提取JSON，原始文本前200字符: 根据提供的信息，`fgets` 函数用于从标准输入（通常是终端）读取字符串。基于 `fgets` 的行为和用途，我们可以分析其在命令注入攻击链中的角色。

### 分析结果

```json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
          
2025-06-08 21:20:10,716 - root - ERROR - 文本repr: '根据提供的信息，`fgets` 函数用于从标准输入（通常是终端）读取字符串。基于 `fgets` 的行为和用途，我们可以分析其在命令注入攻击链中的角色。\n\n### 分析结果\n\n```json\n{\n  '
2025-06-08 21:20:10,716 - CPGvulnHunter.bridges.llmWrapper - ERROR - 分析函数时发生错误: 在文本中未找到有效的JSON内容。文本长度: 702
2025-06-08 21:20:10,716 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误类型: ValueError
2025-06-08 21:20:10,719 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误堆栈: Traceback (most recent call last):
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmWrapper.py", line 224, in analyze_function
    data: dict = self.llm_client.send(llmRequest, True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmBridge.py", line 38, in send
    jsonContent = extract_json_block(response_text)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/utils/uitils.py", line 96, in extract_json_block
    raise ValueError(f"在文本中未找到有效的JSON内容。文本长度: {len(text)}")
ValueError: 在文本中未找到有效的JSON内容。文本长度: 702

2025-06-08 21:20:10,719 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:20:10,719 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:20:10,720 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:20:10,722 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-11cdd839-b7a8-4d74-b2d5-3456a38a4daf', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:20:10,723 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:20:10,724 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:20:10,724 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:20:10,725 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:20:10,725 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:20:10,725 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:20:31,443 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:20:10 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2243'), (b'content-type', b'application/json'), (b'x-process-time', b'21')])
2025-06-08 21:20:31,444 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:20:31,445 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:20:31,445 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:20:31,445 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:20:31,445 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:20:31,446 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:20:10 GMT', 'server': 'uvicorn', 'content-length': '2243', 'content-type': 'application/json', 'x-process-time': '21'})
2025-06-08 21:20:31,446 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:20:31,447 - root - DEBUG - 正在提取JSON，原始文本长度: 780, 清理后长度: 780
2025-06-08 21:20:31,447 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-08 21:20:31,448 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:20:31,448 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 20.73秒
2025-06-08 21:20:31,448 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:20:31,448 - root - INFO - 找到 0 个源函数，0 个汇聚点函数，0 个清理函数
2025-06-08 21:20:31,448 - root - INFO - 源函数列表: []
2025-06-08 21:20:31,448 - root - INFO - 汇聚点函数列表: []
2025-06-08 21:20:31,449 - root - INFO - 清理函数列表: []
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - Pass cwe78 执行成功，耗时: 49.38秒
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - ✓ Pass cwe78 执行成功
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - 总耗时: 92.82秒
2025-06-08 21:20:31,449 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO - 成功的passes: 2
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO -   - init: 成功 (43.44s, 0个发现)
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO -   - cwe78: 成功 (49.38s, 0个发现)
2025-06-08 21:20:31,450 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:20:31,452 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_212031.json
2025-06-08 21:26:36,687 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:26:36,687 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:26:36,687 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:26:36,687 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:26:36,687 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:26:36,687 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:26:36,687 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:26:36,687 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:26:36,687 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:26:36,688 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:26:36,688 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:26:36,688 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:26:36,688 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:26:41,511 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:26:41,512 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:26:41,512 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:26:41,513 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:26:41,513 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:26:41,564 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.05秒
2025-06-08 21:26:41,564 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:26:41,564 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:26:41,564 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:26:41,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:26:41,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:26:43,822 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test110` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test110/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test110/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:26:43,823 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.26秒
2025-06-08 21:26:43,823 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:26:43,823 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.14秒
2025-06-08 21:26:43,823 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:26:43,823 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:26:43,823 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:26:43,824 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:26:43,824 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:26:43,824 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:26:43,824 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:26:43,824 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:26:43,825 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:26:43,826 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:26:44,553 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:26:44,553 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:26:44,954 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:26:44,955 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:26:44,955 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:26:45,342 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:26:45,342 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:26:45,342 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:26:45,703 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:26:45,704 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:26:45,704 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:26:46,048 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:26:46,048 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:26:46,049 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:26:46,399 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:26:46,399 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:26:46,399 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:26:46,760 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:26:46,760 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:26:46,760 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:26:47,112 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:47,112 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:26:47,455 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:26:47,844 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:26:47,844 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:26:48,167 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:48,167 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:26:48,512 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:48,512 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:26:48,840 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:48,840 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:26:49,174 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:26:49,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:26:49,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:26:49,859 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:49,860 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:26:50,198 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:26:50,539 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:26:50,539 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:26:50,857 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:50,858 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:26:51,195 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:26:51,195 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:26:51,196 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:26:51,196 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:26:51,196 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:26:51,196 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:26:51,196 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:26:51,399 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-acce197b-e789-4c9f-8287-2baac10cba17', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:26:51,402 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:26:51,403 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:26:51,404 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x77e05a122a20>
2025-06-08 21:26:51,404 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:26:51,405 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:26:51,405 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:26:51,405 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:26:51,405 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:27:34,196 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:26:50 GMT'), (b'server', b'uvicorn'), (b'content-length', b'928'), (b'content-type', b'application/json'), (b'x-process-time', b'43')])
2025-06-08 21:27:34,197 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:27:34,198 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:27:34,198 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:27:34,198 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:27:34,198 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:27:34,198 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:26:50 GMT', 'server': 'uvicorn', 'content-length': '928', 'content-type': 'application/json', 'x-process-time': '43'})
2025-06-08 21:27:34,198 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:27:34,201 - root - DEBUG - 正在提取JSON，原始文本长度: 214, 清理后长度: 214
2025-06-08 21:27:34,201 - root - DEBUG - 直接解析成功
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 43.01秒
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: 函数printf将格式化参数的数据流向输出
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 43.01秒
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:27:34,201 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:27:34,202 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:27:34,202 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:27:34,203 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d6119547-0597-4040-8b60-1099968e783f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:27:34,203 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:27:34,204 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:27:34,204 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:27:34,204 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:27:34,204 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:27:34,204 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:27:43,622 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:27:33 GMT'), (b'server', b'uvicorn'), (b'content-length', b'904'), (b'content-type', b'application/json'), (b'x-process-time', b'9')])
2025-06-08 21:27:43,622 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:27:43,623 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:27:43,623 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:27:43,623 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:27:43,623 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:27:43,623 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:27:33 GMT', 'server': 'uvicorn', 'content-length': '904', 'content-type': 'application/json', 'x-process-time': '9'})
2025-06-08 21:27:43,623 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:27:43,624 - root - DEBUG - 正在提取JSON，原始文本长度: 202, 清理后长度: 202
2025-06-08 21:27:43,624 - root - DEBUG - 直接解析成功
2025-06-08 21:27:43,624 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.42秒
2025-06-08 21:27:43,624 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:27:43,624 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 数据从流参数流向缓冲区
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.42秒
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:27:43,625 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:27:43,625 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:27:43,625 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:27:43,626 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-b3bdcf93-cee8-476a-bab9-3bdecc51c8a2', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:27:43,627 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:27:43,627 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:27:43,628 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:27:43,628 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:27:43,628 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:27:43,628 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:27:54,672 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:27:42 GMT'), (b'server', b'uvicorn'), (b'content-length', b'978'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:27:54,673 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:27:54,673 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:27:54,673 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:27:54,674 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:27:54,674 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:27:54,674 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:27:42 GMT', 'server': 'uvicorn', 'content-length': '978', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:27:54,674 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:27:54,675 - root - DEBUG - 正在提取JSON，原始文本长度: 232, 清理后长度: 232
2025-06-08 21:27:54,675 - root - DEBUG - 直接解析成功
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.05秒
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: strncpy函数从第二个参数（源字符串）向第一个参数（目标缓冲区）传递数据。
2025-06-08 21:27:54,675 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.05秒
2025-06-08 21:27:54,676 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 63.48秒
2025-06-08 21:27:54,676 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:27:54,676 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:27:54,980 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:27:55,251 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:27:55,251 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:27:55,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:27:55,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:27:55,815 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:27:55,815 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:27:56,266 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:27:56,266 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:27:56,560 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@6434c4c9
=~...
2025-06-08 21:27:56,561 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:27:56,846 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@6434c4c9,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:27:56,846 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:27:56,846 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:27:56,846 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 73.02秒
2025-06-08 21:27:56,846 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:27:56,847 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:27:56,847 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-08 21:27:56,847 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-08 21:27:56,847 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-08 21:27:56,847 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:27:56,847 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:27:56,848 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:27:56,850 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-22081b9a-94a2-4422-b38e-d92d44a2592d', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:27:56,851 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:27:56,852 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:27:56,852 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:27:56,852 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:27:56,853 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:27:56,853 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:28:06,124 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:27:55 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1112'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 21:28:06,125 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:28:06,126 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:28:06,126 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:28:06,126 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:28:06,126 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:28:06,127 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:27:55 GMT', 'server': 'uvicorn', 'content-length': '1112', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 21:28:06,127 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:28:06,128 - root - DEBUG - 正在提取JSON，原始文本长度: 329, 清理后长度: 329
2025-06-08 21:28:06,129 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-08 21:28:06,129 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:28:06,129 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 9.28秒
2025-06-08 21:28:06,130 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:28:06,130 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:28:06,130 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:28:06,130 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:28:06,132 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-6203624b-6c9e-4bc7-a95d-794649f967a3', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:28:06,134 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:28:06,134 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:28:06,135 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:28:06,135 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:28:06,135 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:28:06,135 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:28:23,809 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:28:05 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2099'), (b'content-type', b'application/json'), (b'x-process-time', b'17')])
2025-06-08 21:28:23,810 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:28:23,810 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:28:23,811 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:28:23,811 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:28:23,811 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:28:23,811 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:28:05 GMT', 'server': 'uvicorn', 'content-length': '2099', 'content-type': 'application/json', 'x-process-time': '17'})
2025-06-08 21:28:23,812 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:28:23,813 - root - DEBUG - 正在提取JSON，原始文本长度: 823, 清理后长度: 823
2025-06-08 21:28:23,813 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:28:23,814 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 317)
2025-06-08 21:28:23,814 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:28:23,815 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 317)
2025-06-08 21:28:23,815 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
 ...
2025-06-08 21:28:23,817 - root - ERROR - 无法提取JSON，原始文本前200字符: 根据给定的分析要求和角色定义，对于 `fgets` 函数进行如下分析：

```json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
                "role": "SOURCE",
                "parameter_
2025-06-08 21:28:23,817 - root - ERROR - 文本repr: '根据给定的分析要求和角色定义，对于 `fgets` 函数进行如下分析：\n\n```json\n{\n    "analysis_result": {\n        "function_name": "fg'
2025-06-08 21:28:23,818 - CPGvulnHunter.bridges.llmWrapper - ERROR - 分析函数时发生错误: 在文本中未找到有效的JSON内容。文本长度: 823
2025-06-08 21:28:23,818 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误类型: ValueError
2025-06-08 21:28:23,822 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误堆栈: Traceback (most recent call last):
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmWrapper.py", line 224, in analyze_function
    data: dict = self.llm_client.send(llmRequest, True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmBridge.py", line 38, in send
    jsonContent = extract_json_block(response_text)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/utils/uitils.py", line 1941, in extract_json_block
    raise ValueError(f"在文本中未找到有效的JSON内容。文本长度: {len(text)}")
ValueError: 在文本中未找到有效的JSON内容。文本长度: 823

2025-06-08 21:28:23,822 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:28:23,822 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:28:23,823 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:28:23,825 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-f42d9c82-758a-4126-8c22-05f7582ae035', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:28:23,826 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:28:23,827 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:28:23,827 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:28:23,828 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:28:23,828 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:28:23,828 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:28:37,757 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:28:22 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1699'), (b'content-type', b'application/json'), (b'x-process-time', b'14')])
2025-06-08 21:28:37,758 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:28:37,758 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:28:37,759 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:28:37,759 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:28:37,759 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:28:37,760 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:28:22 GMT', 'server': 'uvicorn', 'content-length': '1699', 'content-type': 'application/json', 'x-process-time': '14'})
2025-06-08 21:28:37,760 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:28:37,761 - root - DEBUG - 正在提取JSON，原始文本长度: 573, 清理后长度: 573
2025-06-08 21:28:37,762 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-08 21:28:37,762 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:28:37,762 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 13.94秒
2025-06-08 21:28:37,762 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:28:37,762 - VulnerabilityEngine - ERROR - Pass cwe78 执行失败: 'CWE78' object has no attribute 'logger'
2025-06-08 21:28:37,763 - VulnerabilityEngine - ERROR - ✗ Pass cwe78 执行失败: ["Pass cwe78 执行失败: 'CWE78' object has no attribute 'logger'"]
2025-06-08 21:28:37,763 - VulnerabilityEngine - WARNING - 非并行模式下遇到错误，停止后续pass执行
2025-06-08 21:28:37,763 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:28:37,763 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:28:37,763 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:28:37,763 - VulnerabilityEngine - INFO - 总耗时: 113.94秒
2025-06-08 21:28:37,763 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO - 成功的passes: 1
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO - 失败的passes: 1
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO -   - init: 成功 (73.02s, 0个发现)
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO -   - cwe78: 失败 (40.92s, 0个发现)
2025-06-08 21:28:37,764 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:28:37,766 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_212837.json
2025-06-08 21:30:39,613 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:30:39,613 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:30:39,613 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:30:39,613 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:30:39,613 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:30:39,614 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:30:39,614 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:30:39,614 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:30:39,614 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:30:39,614 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:30:39,614 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:30:39,614 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:30:39,614 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:30:44,653 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:30:44,654 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:30:44,654 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:30:44,654 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:30:44,654 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:30:44,693 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-08 21:30:44,693 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:30:44,693 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:30:44,693 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:30:44,693 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:30:44,693 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:30:47,057 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test111` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test111/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test111/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:30:47,057 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.36秒
2025-06-08 21:30:47,057 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.44秒
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:30:47,058 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:30:47,059 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:30:47,059 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:30:47,060 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:30:47,060 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:30:47,060 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:30:47,060 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:30:47,060 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:30:47,060 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:30:47,734 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:30:47,734 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:30:48,192 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:30:48,193 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:30:48,193 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:30:48,547 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:30:48,547 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:30:48,548 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:30:48,915 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:30:48,915 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:30:48,915 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:30:49,274 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:30:49,275 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:30:49,275 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:30:49,623 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:30:49,623 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:30:49,623 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:30:49,982 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:30:49,982 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:30:49,982 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:30:50,377 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:50,378 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:30:50,704 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:30:51,136 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:30:51,137 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:30:51,457 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:51,458 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:30:51,832 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:51,832 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:30:52,131 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:52,131 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:30:52,465 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:30:52,800 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:30:52,800 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:30:53,109 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:53,110 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:30:53,450 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:30:53,789 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:30:53,789 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:30:54,100 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:54,100 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:30:54,433 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:30:54,434 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 3
2025-06-08 21:30:54,434 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 3
2025-06-08 21:30:54,434 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 0
2025-06-08 21:30:54,434 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 4
2025-06-08 21:30:54,434 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:30:54,435 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:30:54,435 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:30:54,435 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:30:54,435 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:30:54,436 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:30:54,624 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-cce1185a-c0d0-4b23-ab12-d9cabeb89dee', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:30:54,627 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:30:54,627 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:30:54,629 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x71e5c77714c0>
2025-06-08 21:30:54,629 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:30:54,629 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:30:54,629 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:30:54,630 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:30:54,630 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:31:07,443 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:30:54 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1004'), (b'content-type', b'application/json'), (b'x-process-time', b'13')])
2025-06-08 21:31:07,444 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:31:07,444 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:31:07,444 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:31:07,444 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:31:07,445 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:31:07,445 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:30:54 GMT', 'server': 'uvicorn', 'content-length': '1004', 'content-type': 'application/json', 'x-process-time': '13'})
2025-06-08 21:31:07,445 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:31:07,447 - root - DEBUG - 正在提取JSON，原始文本长度: 240, 清理后长度: 240
2025-06-08 21:31:07,447 - root - DEBUG - 直接解析成功
2025-06-08 21:31:07,447 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 13.01秒
2025-06-08 21:31:07,447 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:31:07,447 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数根据格式字符串和后续参数将数据输出到标准输出，其中第二个参数的数据流向了输出。
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 13.01秒
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:31:07,448 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:31:07,448 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:31:07,448 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:31:07,449 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-5e29b6f4-c6b2-4a0b-8c1b-c3411ca542e3', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:31:07,450 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:31:07,450 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:31:07,450 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:31:07,450 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:31:07,450 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:31:07,450 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:31:09,537 - httpcore.http11 - DEBUG - receive_response_headers.failed exception=KeyboardInterrupt()
2025-06-08 21:31:09,537 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:31:09,537 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:31:36,960 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:31:36,960 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:31:36,960 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:31:36,960 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:31:36,960 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:31:36,960 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:31:36,960 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:31:36,960 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:31:36,960 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:31:36,960 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:31:36,960 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:31:36,960 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:31:36,961 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:31:41,882 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:31:41,882 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:31:41,882 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:31:41,882 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:31:41,882 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:31:41,921 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-08 21:31:41,921 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:31:41,921 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:31:41,921 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:31:41,921 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:31:41,921 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:31:44,176 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test112` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test112/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test112/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:31:44,177 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.26秒
2025-06-08 21:31:44,177 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:31:44,177 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.22秒
2025-06-08 21:31:44,177 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:31:44,177 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:31:44,177 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:31:44,177 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:31:44,178 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:31:44,178 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:31:44,178 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:31:44,178 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:31:44,178 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:31:44,178 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:31:44,179 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:31:44,180 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:31:44,836 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:31:44,836 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total function full names found: 13
2025-06-08 21:31:44,837 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:31:45,246 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:31:45,247 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function dangerous_sink not found.
2025-06-08 21:31:45,247 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:31:45,679 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:31:45,679 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main.c:<global> not found.
2025-06-08 21:31:45,680 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:31:46,049 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:31:46,050 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function safe_sink not found.
2025-06-08 21:31:46,050 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:31:46,378 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:31:46,379 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function input not found.
2025-06-08 21:31:46,379 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:31:46,716 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:31:46,717 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function main not found.
2025-06-08 21:31:46,717 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:31:47,068 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:31:47,068 - CPGvulnHunter.passes.initPass.InitPass - WARNING - Function <includes>:<global> not found.
2025-06-08 21:31:47,069 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:31:47,415 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:47,416 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:31:47,780 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:31:48,177 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:31:48,177 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:31:48,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:48,556 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:31:48,907 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:48,908 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:31:49,235 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:49,236 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:31:49,596 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:31:49,950 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:31:49,951 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:31:50,262 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:50,263 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:31:50,603 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:31:50,952 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:31:50,952 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:31:51,255 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:51,256 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:31:51,611 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:31:51,612 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 3
2025-06-08 21:31:51,612 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 3
2025-06-08 21:31:51,612 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 0
2025-06-08 21:31:51,612 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 4
2025-06-08 21:31:51,612 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:31:51,613 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:31:51,613 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:31:51,613 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:31:51,613 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:31:51,614 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:31:51,794 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-c3fe341d-30ff-4758-9b54-8fd85cb4078f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:31:51,798 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:31:51,798 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:31:51,799 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7a1c5efedf70>
2025-06-08 21:31:51,799 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:31:51,800 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:31:51,800 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:31:51,800 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:31:51,800 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:32:03,995 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:31:51 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1040'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-08 21:32:03,996 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:32:03,996 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:32:03,996 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:32:03,996 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:32:03,996 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:32:03,996 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:31:51 GMT', 'server': 'uvicorn', 'content-length': '1040', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-08 21:32:03,996 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:32:03,998 - root - DEBUG - 正在提取JSON，原始文本长度: 253, 清理后长度: 253
2025-06-08 21:32:03,998 - root - DEBUG - 直接解析成功
2025-06-08 21:32:03,998 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 12.39秒
2025-06-08 21:32:03,998 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:32:03,998 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:32:03,998 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:32:03,999 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: 函数printf的第二个参数是格式化字符串，其中包含实际要打印的数据。这些数据通过输出流（返回值-1）展示给用户或系统。
2025-06-08 21:32:03,999 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 12.39秒
2025-06-08 21:32:03,999 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:32:03,999 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:32:03,999 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:32:03,999 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:32:03,999 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:32:04,000 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-b5372adf-32db-4db2-9d82-748df7db4eee', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:32:04,000 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:32:04,000 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:32:04,001 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:32:04,001 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:32:04,001 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:32:04,001 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:32:13,932 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:32:03 GMT'), (b'server', b'uvicorn'), (b'content-length', b'916'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 21:32:13,933 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:32:13,933 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:32:13,933 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:32:13,933 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:32:13,933 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:32:13,933 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:32:03 GMT', 'server': 'uvicorn', 'content-length': '916', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 21:32:13,933 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:32:13,934 - root - DEBUG - 正在提取JSON，原始文本长度: 210, 清理后长度: 210
2025-06-08 21:32:13,934 - root - DEBUG - 直接解析成功
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.94秒
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 数据从流(参数3)流向缓冲区(参数1)
2025-06-08 21:32:13,934 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.94秒
2025-06-08 21:32:13,935 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:32:13,935 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:32:13,935 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:32:13,935 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:32:13,935 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:32:13,936 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-fa953de7-41be-4ce0-9732-9852f30e46fe', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:32:13,936 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:32:13,937 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:32:13,937 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:32:13,937 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:32:13,937 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:32:13,937 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:32:25,100 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:32:13 GMT'), (b'server', b'uvicorn'), (b'content-length', b'966'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-08 21:32:25,100 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:32:25,101 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:32:25,101 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:32:25,101 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:32:25,101 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:32:25,101 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:32:13 GMT', 'server': 'uvicorn', 'content-length': '966', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-08 21:32:25,101 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:32:25,102 - root - DEBUG - 正在提取JSON，原始文本长度: 230, 清理后长度: 230
2025-06-08 21:32:25,102 - root - DEBUG - 直接解析成功
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.17秒
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: strncpy 函数将源字符串（参数2）的数据传递给目标缓冲区（参数1）。
2025-06-08 21:32:25,102 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.17秒
2025-06-08 21:32:25,103 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 33.49秒
2025-06-08 21:32:25,103 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:32:25,103 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:32:25,421 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:32:25,713 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:32:25,713 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:32:25,983 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:32:25,983 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:32:26,254 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:32:26,254 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:32:26,671 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:32:26,672 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:32:26,944 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5c909d4d
=~...
2025-06-08 21:32:26,945 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:32:27,229 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5c909d4d,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:32:27,229 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:32:27,230 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:32:27,230 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 43.05秒
2025-06-08 21:32:27,230 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:32:27,230 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:32:27,230 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-08 21:32:27,230 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-08 21:32:27,231 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-08 21:32:27,231 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:32:27,231 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:32:27,231 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:32:27,233 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-5265ac07-3525-4df0-9372-fa29dec8425c', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:32:27,235 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:32:27,235 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:32:27,236 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:32:27,236 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:32:27,236 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:32:27,237 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:32:49,748 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:32:26 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2182'), (b'content-type', b'application/json'), (b'x-process-time', b'22')])
2025-06-08 21:32:49,748 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:32:49,749 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:32:49,749 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:32:49,749 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:32:49,749 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:32:49,750 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:32:26 GMT', 'server': 'uvicorn', 'content-length': '2182', 'content-type': 'application/json', 'x-process-time': '22'})
2025-06-08 21:32:49,750 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:32:49,751 - root - DEBUG - 正在提取JSON，原始文本长度: 854, 清理后长度: 854
2025-06-08 21:32:49,752 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-08 21:32:49,752 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:32:49,752 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 22.52秒
2025-06-08 21:32:49,752 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:32:49,753 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:32:49,753 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:32:49,753 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:32:49,755 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-8c6f9d51-9c19-4acf-8d26-eee715d0c04d', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:32:49,756 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:32:49,757 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:32:49,757 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:32:49,758 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:32:49,758 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:32:49,758 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:33:00,037 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:32:49 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1411'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:33:00,038 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:33:00,038 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:33:00,039 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:33:00,039 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:33:00,039 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:33:00,039 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:32:49 GMT', 'server': 'uvicorn', 'content-length': '1411', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:33:00,040 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:33:00,041 - root - DEBUG - 正在提取JSON，原始文本长度: 547, 清理后长度: 547
2025-06-08 21:33:00,041 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:33:00,041 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:33:00,041 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 10.29秒
2025-06-08 21:33:00,042 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:33:00,042 - root - INFO - 函数 fgets 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: fgets 函数用于从标准输入或文件中读取一行数据，通常包含用户输入或其他外部来源的数据。
2025-06-08 21:33:00,042 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:33:00,042 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:33:00,042 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:33:00,044 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-30ef8e90-8aa1-4e9b-bc83-737ed23d60fc', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:33:00,046 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:33:00,046 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:33:00,047 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:33:00,047 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:33:00,047 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:33:00,047 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:33:11,642 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:32:59 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1481'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:33:11,643 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:33:11,643 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:33:11,644 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:33:11,644 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:33:11,644 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:33:11,644 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:32:59 GMT', 'server': 'uvicorn', 'content-length': '1481', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:33:11,645 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:33:11,646 - root - DEBUG - 正在提取JSON，原始文本长度: 483, 清理后长度: 483
2025-06-08 21:33:11,646 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-08 21:33:11,646 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 322)
2025-06-08 21:33:11,647 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-08 21:33:11,647 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 322)
2025-06-08 21:33:11,648 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {...
2025-06-08 21:33:11,650 - root - ERROR - 无法提取JSON，原始文本: ```json
{
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
                "role": "NONE",
                "parameter_index": "-1",
                "confidence": 1.0,
                "reason": "strncpy 是一个字符串拷贝函数，它用于从源字符串复制最多n个字符到目标缓冲区。此操作不涉及用户输入、命令执行或数据清理等行为，因此与命令注入无关。",
            }
        ]
    }
}
```

解释：
- `strncpy` 主要功能是将一个字符串的部分内容拷贝到另一个内存区域。
- 它不会直接引入不受信任的数据（SOURCE），也不会执行任何OS命令（SINK）或进行数据清理和验证（SANITIZER）。
- 因此，可以确定它的角色为NONE。
2025-06-08 21:33:11,650 - CPGvulnHunter.bridges.llmWrapper - ERROR - 分析函数时发生错误: 在文本中未找到有效的JSON内容。文本长度: 483
2025-06-08 21:33:11,650 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误类型: ValueError
2025-06-08 21:33:11,654 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误堆栈: Traceback (most recent call last):
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmWrapper.py", line 224, in analyze_function
    data: dict = self.llm_client.send(llmRequest, True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmBridge.py", line 38, in send
    jsonContent = extract_json_block(response_text)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/utils/uitils.py", line 1940, in extract_json_block
    raise ValueError(f"在文本中未找到有效的JSON内容。文本长度: {len(text)}")
ValueError: 在文本中未找到有效的JSON内容。文本长度: 483

2025-06-08 21:33:11,654 - CWE78 - INFO - 分析完成，找到 1 个源函数，0 个汇聚点函数，0 个清理函数
2025-06-08 21:33:11,654 - root - INFO - 找到 1 个源函数，0 个汇聚点函数，0 个清理函数
2025-06-08 21:33:11,654 - root - INFO - 源函数列表: ['fgets']
2025-06-08 21:33:11,654 - root - INFO - 汇聚点函数列表: []
2025-06-08 21:33:11,654 - root - INFO - 清理函数列表: []
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - Pass cwe78 执行成功，耗时: 44.42秒
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - ✓ Pass cwe78 执行成功
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - 总耗时: 87.48秒
2025-06-08 21:33:11,655 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO - 成功的passes: 2
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO -   - init: 成功 (43.05s, 0个发现)
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO -   - cwe78: 成功 (44.42s, 0个发现)
2025-06-08 21:33:11,656 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:33:11,657 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_213311.json
2025-06-08 21:35:17,185 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:35:17,185 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-08 21:35:17,185 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-08 21:35:17,185 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-08 21:35:17,185 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-08 21:35:17,185 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-08 21:35:17,186 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-08 21:35:17,186 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:35:17,186 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:35:17,186 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-08 21:35:17,186 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-08 21:35:17,186 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-08 21:35:17,186 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-08 21:35:22,091 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-08 21:35:22,092 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-08 21:35:22,092 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-08 21:35:22,092 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-08 21:35:22,092 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-08 21:35:22,132 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-08 21:35:22,132 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-08 21:35:22,132 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-08 21:35:22,132 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-08 21:35:22,132 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-08 21:35:22,132 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-08 21:35:24,516 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test113` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test113/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test113/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-08 21:35:24,517 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.38秒
2025-06-08 21:35:24,517 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-08 21:35:24,517 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.33秒
2025-06-08 21:35:24,517 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-08 21:35:24,518 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-08 21:35:24,518 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-08 21:35:24,518 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-08 21:35:24,518 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-08 21:35:24,518 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-08 21:35:24,518 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO - 分析配置:
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-08 21:35:24,519 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-08 21:35:24,520 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-08 21:35:24,520 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-08 21:35:25,195 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-08 21:35:25,195 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total function full names found: 13
2025-06-08 21:35:25,195 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-08 21:35:25,581 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:35:25,581 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-08 21:35:25,954 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:35:25,955 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-08 21:35:26,343 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:35:26,343 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-08 21:35:26,714 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:35:26,715 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-08 21:35:27,092 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-08 21:35:27,093 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-08 21:35:27,403 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-08 21:35:27,404 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-08 21:35:27,726 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:27,727 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-08 21:35:28,085 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-08 21:35:28,458 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:35:28,458 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-08 21:35:28,785 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:28,786 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-08 21:35:29,146 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:29,147 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-08 21:35:29,473 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:29,473 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-08 21:35:29,786 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:35:30,153 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-08 21:35:30,154 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-08 21:35:30,485 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:30,485 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-08 21:35:30,832 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-08 21:35:31,174 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-08 21:35:31,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-08 21:35:31,482 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:31,483 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-08 21:35:31,822 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-08 21:35:31,822 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 9
2025-06-08 21:35:31,822 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 3
2025-06-08 21:35:31,823 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 6
2025-06-08 21:35:31,823 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 4
2025-06-08 21:35:31,823 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-08 21:35:31,823 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-08 21:35:31,823 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-08 21:35:31,823 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-08 21:35:31,824 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:35:31,824 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:35:32,011 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2f15aa22-f33d-4711-a9d0-fb1117898332', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:35:32,014 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:35:32,014 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-08 21:35:32,016 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7866ec8167e0>
2025-06-08 21:35:32,016 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:35:32,016 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:35:32,016 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:35:32,016 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:35:32,016 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:35:45,105 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:35:31 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1029'), (b'content-type', b'application/json'), (b'x-process-time', b'13')])
2025-06-08 21:35:45,106 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:35:45,106 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:35:45,107 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:35:45,107 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:35:45,107 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:35:45,107 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:35:31 GMT', 'server': 'uvicorn', 'content-length': '1029', 'content-type': 'application/json', 'x-process-time': '13'})
2025-06-08 21:35:45,107 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:35:45,109 - root - DEBUG - 正在提取JSON，原始文本长度: 248, 清理后长度: 248
2025-06-08 21:35:45,109 - root - DEBUG - 直接解析成功
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 13.29秒
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数的第二个参数是格式化字符串，其中包含需要输出的数据。这些数据通过返回值（即实际输出）传播出去。
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 13.29秒
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-08 21:35:45,109 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-08 21:35:45,110 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-08 21:35:45,110 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:35:45,110 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:35:45,111 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-1a23a2c5-4281-453a-84e4-979a5d214adc', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:35:45,111 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:35:45,111 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:35:45,112 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:35:45,112 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:35:45,112 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:35:45,112 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:35:55,415 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:35:44 GMT'), (b'server', b'uvicorn'), (b'content-length', b'958'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-08 21:35:55,416 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:35:55,416 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:35:55,416 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:35:55,416 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:35:55,416 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:35:55,416 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:35:44 GMT', 'server': 'uvicorn', 'content-length': '958', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-08 21:35:55,416 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:35:55,417 - root - DEBUG - 正在提取JSON，原始文本长度: 221, 清理后长度: 221
2025-06-08 21:35:55,417 - root - DEBUG - 直接解析成功
2025-06-08 21:35:55,417 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 10.31秒
2025-06-08 21:35:55,417 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-08 21:35:55,417 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 根据函数签名和用法，数据从流（参数3）流向缓冲区（参数1）。
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 10.31秒
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-08 21:35:55,418 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-08 21:35:55,418 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-08 21:35:55,418 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:35:55,419 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-0511f341-fbd5-47d3-972c-146069665c75', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:35:55,420 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:35:55,420 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:35:55,420 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:35:55,420 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:35:55,421 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:35:55,421 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:36:06,882 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:35:54 GMT'), (b'server', b'uvicorn'), (b'content-length', b'986'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:36:06,882 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:36:06,882 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:36:06,883 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:36:06,883 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:36:06,883 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:36:06,883 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:35:54 GMT', 'server': 'uvicorn', 'content-length': '986', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:36:06,883 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:36:06,884 - root - DEBUG - 正在提取JSON，原始文本长度: 236, 清理后长度: 236
2025-06-08 21:36:06,884 - root - DEBUG - 直接解析成功
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.47秒
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 根据函数签名和用法，strncpy从源字符串（参数2）复制数据到目标缓冲区（参数1）。
2025-06-08 21:36:06,884 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.47秒
2025-06-08 21:36:06,885 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 35.06秒
2025-06-08 21:36:06,885 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-08 21:36:06,885 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-08 21:36:07,124 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-08 21:36:07,380 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-08 21:36:07,380 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-08 21:36:07,663 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-08 21:36:07,663 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-08 21:36:07,943 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-08 21:36:07,944 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-08 21:36:08,401 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-08 21:36:08,401 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-08 21:36:08,683 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5efa1444
=~...
2025-06-08 21:36:08,683 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-08 21:36:08,966 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5efa1444,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-08 21:36:08,967 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-08 21:36:08,967 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-08 21:36:08,967 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 44.45秒
2025-06-08 21:36:08,967 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-08 21:36:08,967 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:36:08,968 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-08 21:36:08,968 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-08 21:36:08,968 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-08 21:36:08,968 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:36:08,968 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: dangerous_sink\nFull Name: dangerous_sink\nSignature: void(char[])\nFile: main.c\ncode: void dangerous_sink(char data[]) {\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "dangerous_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:36:08,969 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:36:08,971 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-f2440032-12b6-4f08-b8bc-389a72e55632', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: dangerous_sink\nFull Name: dangerous_sink\nSignature: void(char[])\nFile: main.c\ncode: void dangerous_sink(char data[]) {\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "dangerous_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:36:08,972 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:36:08,973 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:36:08,973 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:36:08,973 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:36:08,974 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:36:08,974 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:36:42,662 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:36:08 GMT'), (b'server', b'uvicorn'), (b'content-length', b'3176'), (b'content-type', b'application/json'), (b'x-process-time', b'34')])
2025-06-08 21:36:42,662 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:36:42,663 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:36:42,663 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:36:42,663 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:36:42,664 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:36:42,664 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:36:08 GMT', 'server': 'uvicorn', 'content-length': '3176', 'content-type': 'application/json', 'x-process-time': '34'})
2025-06-08 21:36:42,664 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:36:42,665 - root - DEBUG - 正在提取JSON，原始文本长度: 1244, 清理后长度: 1244
2025-06-08 21:36:42,666 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "dangerous_sink",
        "roles": [
           ...
2025-06-08 21:36:42,666 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 8 column 36 (char 208)
2025-06-08 21:36:42,667 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "dangerous_sink",
        "roles": [
           ...
2025-06-08 21:36:42,667 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 8 column 36 (char 208)
2025-06-08 21:36:42,668 - root - DEBUG - 模式 3 找到内容: c
void dangerous_sink(char data[]) {
    printf("SINK: Received potentially dangerous data: %d\n", d...
2025-06-08 21:36:42,668 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "dangerous_sink",
        "roles": [
      ...
2025-06-08 21:36:42,669 - root - DEBUG - 找到嵌入JSON: []...
2025-06-08 21:36:42,669 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 33.70秒
2025-06-08 21:36:42,669 - CPGvulnHunter.bridges.llmWrapper - ERROR - LLM返回数据不是字典类型: <class 'list'>
2025-06-08 21:36:42,670 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:36:42,670 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: main.c:<global>\nSignature: N/A\nFile: main.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:36:42,670 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:36:42,672 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2efcd070-e4ef-4992-a09f-7eb0fe8fb757', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: main.c:<global>\nSignature: N/A\nFile: main.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:36:42,673 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:36:42,674 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:36:42,675 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:36:42,675 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:36:42,675 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:36:42,675 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:37:07,052 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:36:42 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2727'), (b'content-type', b'application/json'), (b'x-process-time', b'25')])
2025-06-08 21:37:07,053 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:37:07,054 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:37:07,054 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:37:07,055 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:37:07,055 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:37:07,055 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:36:42 GMT', 'server': 'uvicorn', 'content-length': '2727', 'content-type': 'application/json', 'x-process-time': '25'})
2025-06-08 21:37:07,055 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:37:07,057 - root - DEBUG - 正在提取JSON，原始文本长度: 1182, 清理后长度: 1182
2025-06-08 21:37:07,057 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "main.c:<global>",
        "roles": [
          ...
2025-06-08 21:37:07,057 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:37:07,057 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 24.39秒
2025-06-08 21:37:07,057 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:37:07,058 - root - INFO - 函数 <global> 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: 从标准输入读取数据，可能来自不受信任的用户。
2025-06-08 21:37:07,058 - root - INFO - 函数 <global> 角色: SINK, 参数索引: -1, 置信度: 1.0, 理由: 调用system函数执行命令注入攻击。
2025-06-08 21:37:07,058 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:37:07,058 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: safe_sink\nFull Name: safe_sink\nSignature: void(int)\nFile: main.c\ncode: void safe_sink(int data) {\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "safe_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:37:07,058 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:37:07,060 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-4b05f5e4-2721-4334-8ccf-1f5360cfc911', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: safe_sink\nFull Name: safe_sink\nSignature: void(int)\nFile: main.c\ncode: void safe_sink(int data) {\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "safe_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:37:07,062 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:37:07,062 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:37:07,063 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:37:07,063 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:37:07,063 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:37:07,063 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:37:31,062 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:37:06 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2582'), (b'content-type', b'application/json'), (b'x-process-time', b'24')])
2025-06-08 21:37:31,063 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:37:31,064 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:37:31,064 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:37:31,064 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:37:31,064 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:37:31,065 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:37:06 GMT', 'server': 'uvicorn', 'content-length': '2582', 'content-type': 'application/json', 'x-process-time': '24'})
2025-06-08 21:37:31,065 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:37:31,066 - root - DEBUG - 正在提取JSON，原始文本长度: 1014, 清理后长度: 1014
2025-06-08 21:37:31,067 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "safe_sink",
        "roles": [
            {
  ...
2025-06-08 21:37:31,067 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:37:31,067 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 24.01秒
2025-06-08 21:37:31,067 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:37:31,067 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:37:31,067 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: input\nFull Name: input\nSignature: char*()\nFile: main.c\ncode: char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:37:31,068 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:37:31,070 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-eb4ccba7-b83b-43d3-aa9c-21c2fab9e0b2', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: input\nFull Name: input\nSignature: char*()\nFile: main.c\ncode: char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:37:31,071 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:37:31,072 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:37:31,072 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:37:31,073 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:37:31,073 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:37:31,073 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:37:50,183 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:37:30 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2099'), (b'content-type', b'application/json'), (b'x-process-time', b'19')])
2025-06-08 21:37:50,184 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:37:50,184 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:37:50,185 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:37:50,185 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:37:50,185 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:37:50,185 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:37:30 GMT', 'server': 'uvicorn', 'content-length': '2099', 'content-type': 'application/json', 'x-process-time': '19'})
2025-06-08 21:37:50,185 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:37:50,187 - root - DEBUG - 正在提取JSON，原始文本长度: 727, 清理后长度: 727
2025-06-08 21:37:50,187 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "input",
        "roles": [
            {
      ...
2025-06-08 21:37:50,187 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:37:50,187 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 19.12秒
2025-06-08 21:37:50,188 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:37:50,188 - root - INFO - 函数 input 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: 函数从标准输入读取数据，返回值为用户输入的不受信任的数据。
2025-06-08 21:37:50,188 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:37:50,188 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: main.c\ncode: int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:37:50,188 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:37:50,190 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-3eb0960b-6422-4f8b-af70-75ae3d3ce10f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: main.c\ncode: int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:37:50,192 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:37:50,193 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:37:50,193 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:37:50,194 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:37:50,194 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:37:50,194 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:38:10,050 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:37:49 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2023'), (b'content-type', b'application/json'), (b'x-process-time', b'20')])
2025-06-08 21:38:10,050 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:38:10,051 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:38:10,051 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:38:10,051 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:38:10,052 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:38:10,052 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:37:49 GMT', 'server': 'uvicorn', 'content-length': '2023', 'content-type': 'application/json', 'x-process-time': '20'})
2025-06-08 21:38:10,052 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:38:10,053 - root - DEBUG - 正在提取JSON，原始文本长度: 798, 清理后长度: 798
2025-06-08 21:38:10,054 - root - DEBUG - 模式 1 找到内容: {
  "analysis_result": {
    "function_name": "main",
    "roles": [
      {
        "role": "SOURCE...
2025-06-08 21:38:10,054 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:38:10,054 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 19.87秒
2025-06-08 21:38:10,054 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:38:10,054 - root - INFO - 函数 main 角色: SOURCE, 参数索引: -1, 置信度: 0.9, 理由: 函数调用input()来获取用户输入，这通常是一个潜在的数据来源。
2025-06-08 21:38:10,054 - root - INFO - 函数 main 角色: SINK, 参数索引: 1, 置信度: 0.85, 理由: dangerous_sink(data) 函数名暗示其可能执行危险操作，如操作系统命令注入。
2025-06-08 21:38:10,055 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:38:10,055 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:38:10,055 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:38:10,057 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-f7ba7571-a75c-4783-9be5-32bf06c29fcf', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:38:10,058 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:38:10,059 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:38:10,060 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:38:10,060 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:38:10,060 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:38:10,060 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:38:21,414 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:38:09 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1515'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-08 21:38:21,415 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:38:21,415 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:38:21,416 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:38:21,416 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:38:21,416 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:38:21,416 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:38:09 GMT', 'server': 'uvicorn', 'content-length': '1515', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-08 21:38:21,416 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:38:21,418 - root - DEBUG - 正在提取JSON，原始文本长度: 479, 清理后长度: 479
2025-06-08 21:38:21,418 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "<includes>:<global>",
        "roles": [
      ...
2025-06-08 21:38:21,418 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:38:21,419 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 11.36秒
2025-06-08 21:38:21,419 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:38:21,419 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:38:21,419 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:38:21,419 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:38:21,422 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d6f93361-70f2-44b2-b1a9-a20865ff0922', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:38:21,423 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:38:21,424 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:38:21,424 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:38:21,425 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:38:21,425 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:38:21,425 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:38:35,305 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:38:20 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1655'), (b'content-type', b'application/json'), (b'x-process-time', b'14')])
2025-06-08 21:38:35,306 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:38:35,306 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:38:35,307 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:38:35,307 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:38:35,307 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:38:35,307 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:38:20 GMT', 'server': 'uvicorn', 'content-length': '1655', 'content-type': 'application/json', 'x-process-time': '14'})
2025-06-08 21:38:35,308 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:38:35,309 - root - DEBUG - 正在提取JSON，原始文本长度: 558, 清理后长度: 558
2025-06-08 21:38:35,309 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-08 21:38:35,309 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:38:35,309 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 13.89秒
2025-06-08 21:38:35,310 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:38:35,310 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:38:35,310 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:38:35,310 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:38:35,312 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-a9f05e6b-73bb-4bca-a4f1-63ed56b93426', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:38:35,314 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:38:35,314 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:38:35,315 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:38:35,315 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:38:35,315 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:38:35,315 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:38:54,748 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:38:34 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2189'), (b'content-type', b'application/json'), (b'x-process-time', b'19')])
2025-06-08 21:38:54,749 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:38:54,749 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:38:54,749 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:38:54,750 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:38:54,750 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:38:54,750 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:38:34 GMT', 'server': 'uvicorn', 'content-length': '2189', 'content-type': 'application/json', 'x-process-time': '19'})
2025-06-08 21:38:54,750 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:38:54,751 - root - DEBUG - 正在提取JSON，原始文本长度: 769, 清理后长度: 769
2025-06-08 21:38:54,752 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:38:54,752 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 7 column 42 (char 169)
2025-06-08 21:38:54,752 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-08 21:38:54,753 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 7 column 42 (char 169)
2025-06-08 21:38:54,753 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
 ...
2025-06-08 21:38:54,754 - root - ERROR - 无法提取JSON，原始文本: 根据提供的信息，`fgets()` 函数用于从标准输入、文件流或其他数据源读取一行文本。它通常被用来获取用户的输入或者从文件中读取内容。

1. **角色分析：**
   - `fgets()` 读取字符串并返回结果到一个缓冲区。
   - 如果这个函数的参数（如用户通过键盘输入或文件中的内容）包含不可信的数据，可能会导致命令注入漏洞。
   - 因此，在没有其他上下文的情况下，`fgets()` 可以被认为是获取不受信任数据的源。

```json
{
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
                "role": "SOURCE",
                "parameter_index": "-1", // 表示返回值
                "confidence": 0.9,
                "reason": "函数从用户输入或文件中读取数据，这些来源可能包含不受信任的数据。",
            }
        ]
    }
}
```

**解释：**
- **SOURCE:** `fgets()` 作为用户输入的接收者，它直接与用户交互获取数据。如果传入的是网络输入、环境变量或者其他不可信的数据源，那么这个函数可能会成为注入攻击的起点。
  
由于`fgets()`不具备执行系统命令的能力，并且不包含清理或验证用户的输入的功能，所以它不会被归类为SINK或SANITIZER。因此，置信度可以设置得非常高（接近1.0），但由于题目要求置信度 >= 0.6 即可返回结果，这里设定为0.9。
2025-06-08 21:38:54,754 - CPGvulnHunter.bridges.llmWrapper - ERROR - 分析函数时发生错误: 在文本中未找到有效的JSON内容。文本长度: 769
2025-06-08 21:38:54,754 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误类型: ValueError
2025-06-08 21:38:54,758 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误堆栈: Traceback (most recent call last):
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmWrapper.py", line 224, in analyze_function
    data: dict = self.llm_client.send(llmRequest, True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmBridge.py", line 38, in send
    jsonContent = extract_json_block(response_text)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/utils/uitils.py", line 1940, in extract_json_block
    raise ValueError(f"在文本中未找到有效的JSON内容。文本长度: {len(text)}")
ValueError: 在文本中未找到有效的JSON内容。文本长度: 769

2025-06-08 21:38:54,759 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-08 21:38:54,759 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-08 21:38:54,759 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-08 21:38:54,761 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-642acc35-458f-4019-9c4c-267d78d6885b', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-08 21:38:54,763 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-08 21:38:54,763 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-08 21:38:54,764 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-08 21:38:54,764 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-08 21:38:54,764 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-08 21:38:54,764 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-08 21:39:16,200 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Sun, 08 Jun 2025 13:38:53 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2404'), (b'content-type', b'application/json'), (b'x-process-time', b'22')])
2025-06-08 21:39:16,200 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-08 21:39:16,201 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-08 21:39:16,201 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-08 21:39:16,201 - httpcore.http11 - DEBUG - response_closed.started
2025-06-08 21:39:16,202 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-08 21:39:16,202 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Sun, 08 Jun 2025 13:38:53 GMT', 'server': 'uvicorn', 'content-length': '2404', 'content-type': 'application/json', 'x-process-time': '22'})
2025-06-08 21:39:16,202 - openai._base_client - DEBUG - request_id: None
2025-06-08 21:39:16,203 - root - DEBUG - 正在提取JSON，原始文本长度: 864, 清理后长度: 864
2025-06-08 21:39:16,204 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-08 21:39:16,204 - root - DEBUG - 模式 1 解析成功
2025-06-08 21:39:16,204 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 21.45秒
2025-06-08 21:39:16,204 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-08 21:39:16,204 - CWE78 - INFO - 分析完成，找到 3 个源函数，2 个汇聚点函数，0 个清理函数
2025-06-08 21:39:16,204 - root - INFO - 找到 3 个源函数，2 个汇聚点函数，0 个清理函数
2025-06-08 21:39:16,205 - root - INFO - 源函数列表: ['main.c:<global>', 'input', 'main']
2025-06-08 21:39:16,205 - root - INFO - 汇聚点函数列表: ['main.c:<global>', 'main']
2025-06-08 21:39:16,205 - root - INFO - 清理函数列表: []
2025-06-08 21:39:16,205 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").methodReturn.reachableByDetailed(cpg.method.fullName("main.c:<global>").methodReturn).toJsonPretty...
2025-06-08 21:39:16,675 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").methodReturn.reachableByDetailed(c
cpg.method.fullName("main.c:<global>").methodReturn).toJsonPretty
>val res22: String = """[
  
]"""
=~...
2025-06-08 21:39:16,676 - root - INFO - 分析源 main.c:<global> 到汇聚点 main.c:<global> 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0)
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO - Pass cwe78 执行成功，耗时: 187.71秒
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO - ✓ Pass cwe78 执行成功
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO - 
============================================================
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-08 21:39:16,676 - VulnerabilityEngine - INFO - ============================================================
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 总耗时: 232.16秒
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 成功的passes: 2
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO -   - init: 成功 (44.45s, 0个发现)
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO -   - cwe78: 成功 (187.71s, 0个发现)
2025-06-08 21:39:16,677 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-08 21:39:16,679 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250608_213916.json
2025-06-09 13:31:47,233 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-09 13:31:47,233 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-09 13:31:47,233 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-09 13:31:47,234 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-09 13:31:47,234 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-09 13:31:47,234 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-09 13:31:47,234 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-09 13:31:47,234 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-09 13:31:47,234 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-09 13:31:47,234 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-09 13:31:47,234 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-09 13:31:47,234 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-09 13:31:47,234 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-09 13:31:52,163 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-09 13:31:52,163 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-09 13:31:52,163 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-09 13:31:52,163 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-09 13:31:52,163 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-09 13:31:52,202 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.04秒
2025-06-09 13:31:52,202 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-09 13:31:52,202 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-09 13:31:52,202 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-09 13:31:52,202 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test1
2025-06-09 13:31:52,202 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")...
2025-06-09 13:31:54,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test1")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test114` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test1`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test1 --output /home/nstl/data/CPGvulnHunter/workspace/test114/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test114/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[152 nodes]]
=~...
2025-06-09 13:31:54,565 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.36秒
2025-06-09 13:31:54,565 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-09 13:31:54,565 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.33秒
2025-06-09 13:31:54,565 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-09 13:31:54,566 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-09 13:31:54,566 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-09 13:31:54,566 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-09 13:31:54,566 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-09 13:31:54,567 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO - 分析配置:
2025-06-09 13:31:54,567 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-09 13:31:54,568 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-09 13:31:54,568 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-09 13:31:54,568 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-09 13:31:54,568 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-09 13:31:54,568 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-09 13:31:54,568 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-09 13:31:55,190 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "dangerous_sink",
  "main.c:<global>",
  "safe_sink",
  "input",
  "main",
  "<includes>:<global>",
  "printf",
  "<operator>.assignment",
  "<operator>.alloc",
  "fgets",
  "strncpy",
  "<operator>.subtraction",
  "<operator>.sizeOf"
]"""
=~...
2025-06-09 13:31:55,191 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total function full names found: 13
2025-06-09 13:31:55,191 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("dangerous_sink").toJsonPretty...
2025-06-09 13:31:55,583 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("dangerous_sink").toJsonPretty
>val res2: String = """[
  {
    "name":"dangerous_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149696,
    "signature":"void(char[])",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":11,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"dangerous_sink",
    "genericSignature":"<empty>",
    "code":"void dangerous_sink(char data[]) {\n    printf(\"SINK: Received potentially dangerous data: %d\\n\", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}",
    "isExternal":false,
    "lineNumber":8,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-09 13:31:55,584 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main.c:<global>").toJsonPretty...
2025-06-09 13:31:55,978 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"main.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-09 13:31:55,979 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("safe_sink").toJsonPretty...
2025-06-09 13:31:56,364 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("safe_sink").toJsonPretty
>val res4: String = """[
  {
    "name":"safe_sink",
    "astParentFullName":"main.c:<global>",
    "_id":111669149698,
    "signature":"void(int)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":16,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"safe_sink",
    "genericSignature":"<empty>",
    "code":"void safe_sink(int data) {\n    printf(\"SAFE SINK: Safely processed data: %d\\n\", data);\n}",
    "isExternal":false,
    "lineNumber":14,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-09 13:31:56,365 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("input").toJsonPretty...
2025-06-09 13:31:56,761 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("input").toJsonPretty
>val res5: String = """[
  {
    "name":"input",
    "astParentFullName":"main.c:<global>",
    "_id":111669149699,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":22,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"input",
    "genericSignature":"<empty>",
    "code":"char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}",
    "isExternal":false,
    "lineNumber":18,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-09 13:31:56,761 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-09 13:31:57,107 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res6: String = """[
  {
    "name":"main",
    "astParentFullName":"main.c:<global>",
    "_id":111669149700,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":33,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n    printf(\"=== 数据流传播测试 ===\\n\");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}",
    "isExternal":false,
    "lineNumber":24,
    "columnNumber":1,
    "order":1,
    "filename":"main.c"
  }
]"""
=~...
2025-06-09 13:31:57,107 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-09 13:31:57,492 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res7: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149701,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-09 13:31:57,493 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-09 13:31:57,816 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res8: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:31:57,816 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-09 13:31:58,087 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res9: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116994,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964116995,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:31:58,449 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}', '{\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}', '{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-09 13:31:58,450 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-09 13:31:58,780 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res11: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:31:58,781 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-09 13:31:59,121 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res12: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:31:59,122 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-09 13:31:59,448 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res13: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:31:59,449 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-09 13:31:59,787 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res14: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:32:00,156 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}']
2025-06-09 13:32:00,157 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").toJsonPretty...
2025-06-09 13:32:00,479 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").toJsonPretty
>val res16: String = """[
  {
    "name":"strncpy",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strncpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:32:00,480 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strncpy").parameter.toJsonPretty...
2025-06-09 13:32:00,832 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strncpy").parameter.toJsonPretty
>val res17: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117004,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:32:01,195 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strncpy 的使用情况: ['{\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}']
2025-06-09 13:32:01,195 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-09 13:32:01,514 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res19: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:32:01,515 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-09 13:32:01,911 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:32:01,912 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 9
2025-06-09 13:32:01,912 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 3
2025-06-09 13:32:01,912 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 6
2025-06-09 13:32:01,912 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 4
2025-06-09 13:32:01,912 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 3 个外部函数
2025-06-09 13:32:01,913 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/3: printf
2025-06-09 13:32:01,913 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-09 13:32:01,913 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-09 13:32:01,913 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:32:01,913 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:32:02,104 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2db97440-b45f-4d96-b7af-8492c9b80bcb', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("SINK: Received potentially dangerous data: %d\\\\n", data);\\n    // 模拟危险操作，如系统调用、文件写入等\\n}\', \'{\\n    printf("SAFE SINK: Safely processed data: %d\\\\n", data);\\n}\', \'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:32:02,107 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:32:02,107 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-09 13:32:02,109 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7ec39c9b8920>
2025-06-09 13:32:02,109 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:32:02,109 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:32:02,109 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:32:02,109 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:32:02,109 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:32:45,404 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:32:01 GMT'), (b'server', b'uvicorn'), (b'content-length', b'934'), (b'content-type', b'application/json'), (b'x-process-time', b'43')])
2025-06-09 13:32:45,405 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:32:45,405 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:32:45,405 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:32:45,405 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:32:45,406 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:32:45,406 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:32:01 GMT', 'server': 'uvicorn', 'content-length': '934', 'content-type': 'application/json', 'x-process-time': '43'})
2025-06-09 13:32:45,406 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:32:45,408 - root - DEBUG - 正在提取JSON，原始文本长度: 216, 清理后长度: 216
2025-06-09 13:32:45,408 - root - DEBUG - 直接解析成功
2025-06-09 13:32:45,408 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 43.50秒
2025-06-09 13:32:45,408 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数中，格式化参数的数据流向输出。
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 43.50秒
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/3: fgets
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-09 13:32:45,409 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-09 13:32:45,409 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:32:45,409 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:32:45,410 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-9f68b062-9550-419c-a6bd-8eb52ce5d132', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    char data[100];\\n    fgets(data,100,stdin);\\n    return data;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:32:45,411 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:32:45,411 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:32:45,412 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:32:45,412 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:32:45,412 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:32:45,412 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:32:55,237 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:32:44 GMT'), (b'server', b'uvicorn'), (b'content-length', b'940'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:32:55,238 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:32:55,238 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:32:55,238 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:32:55,238 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:32:55,238 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:32:55,239 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:32:44 GMT', 'server': 'uvicorn', 'content-length': '940', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:32:55,239 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:32:55,239 - root - DEBUG - 正在提取JSON，原始文本长度: 214, 清理后长度: 214
2025-06-09 13:32:55,240 - root - DEBUG - 直接解析成功
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 9.83秒
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 根据函数签名和用法，数据从文件流流向目标缓冲区
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 9.83秒
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/3: strncpy
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strncpy
2025-06-09 13:32:55,240 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strncpy 构建分析请求完成
2025-06-09 13:32:55,240 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:32:55,240 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:32:55,241 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d42a827b-f0be-4691-a03a-648a5dd2291a', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strncpy\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("=== 数据流传播测试 ===\\\\n");\\n    char* ptr;\\n    char data[256];\\n    ptr = input();\\n    strncpy(data, ptr, sizeof(data) - 1);\\n    dangerous_sink(data);\\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\\n\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strncpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:32:55,242 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:32:55,242 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:32:55,243 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:32:55,243 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:32:55,243 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:32:55,243 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:33:06,545 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:32:54 GMT'), (b'server', b'uvicorn'), (b'content-length', b'988'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:33:06,545 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:33:06,545 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:33:06,546 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:33:06,546 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:33:06,546 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:33:06,546 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:32:54 GMT', 'server': 'uvicorn', 'content-length': '988', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:33:06,546 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:33:06,547 - root - DEBUG - 正在提取JSON，原始文本长度: 232, 清理后长度: 232
2025-06-09 13:33:06,547 - root - DEBUG - 直接解析成功
2025-06-09 13:33:06,547 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy LLM请求完成，耗时: 11.31秒
2025-06-09 13:33:06,547 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-09 13:33:06,547 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 添加参数流 1: 2 -> 1
2025-06-09 13:33:06,547 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:33:06,548 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strncpy 分析依据: 根据函数签名和用法，数据从第2个参数（源字符串）流向第1个参数（目标缓冲区）。
2025-06-09 13:33:06,548 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strncpy 分析成功，耗时: 11.31秒
2025-06-09 13:33:06,548 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 3, 失败: 0, 总耗时: 64.64秒
2025-06-09 13:33:06,548 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 3 条语义规则
2025-06-09 13:33:06,548 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-09 13:33:06,890 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-09 13:33:07,177 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-09 13:33:07,177 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-09 13:33:07,467 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-09 13:33:07,467 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-09 13:33:07,752 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-09 13:33:07,753 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strncpy", List((2, 1)), regex = false))...
2025-06-09 13:33:08,199 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("printf", List((2, -1)), regex = 
 false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strncpy", List((2, 1)), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strncpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  )
)
=~...
2025-06-09 13:33:08,199 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-09 13:33:08,491 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5efa1444
=~...
2025-06-09 13:33:08,491 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-09 13:33:08,782 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@5efa1444,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-09 13:33:08,782 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-09 13:33:08,782 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 3 semantic rules for external functions.
2025-06-09 13:33:08,783 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 74.21秒
2025-06-09 13:33:08,783 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-09 13:33:08,783 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-09 13:33:08,783 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-09 13:33:08,783 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-09 13:33:08,783 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-09 13:33:08,784 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:33:08,784 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: dangerous_sink\nFull Name: dangerous_sink\nSignature: void(char[])\nFile: main.c\ncode: void dangerous_sink(char data[]) {\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "dangerous_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:33:08,784 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:33:08,786 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-22ea40f9-475b-42b5-9ada-c1d36aa6ef15', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: dangerous_sink\nFull Name: dangerous_sink\nSignature: void(char[])\nFile: main.c\ncode: void dangerous_sink(char data[]) {\n    printf("SINK: Received potentially dangerous data: %d\\n", data);\n    // 模拟危险操作，如系统调用、文件写入等\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "dangerous_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:33:08,788 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:33:08,788 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:33:08,789 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:33:08,789 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:33:08,789 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:33:08,789 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:33:32,189 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:33:08 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2283'), (b'content-type', b'application/json'), (b'x-process-time', b'24')])
2025-06-09 13:33:32,190 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:33:32,190 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:33:32,190 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:33:32,191 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:33:32,191 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:33:32,191 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:33:08 GMT', 'server': 'uvicorn', 'content-length': '2283', 'content-type': 'application/json', 'x-process-time': '24'})
2025-06-09 13:33:32,191 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:33:32,192 - root - DEBUG - 正在提取JSON，原始文本长度: 921, 清理后长度: 921
2025-06-09 13:33:32,193 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "dangerous_sink",
        "roles": [
           ...
2025-06-09 13:33:32,194 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:33:32,194 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 23.41秒
2025-06-09 13:33:32,194 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:33:32,194 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:33:32,194 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: main.c:<global>\nSignature: N/A\nFile: main.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:33:32,194 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:33:32,197 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-c232a181-2e71-4e94-b848-6deebafd7c58', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: main.c:<global>\nSignature: N/A\nFile: main.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:33:32,198 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:33:32,198 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:33:32,199 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:33:32,199 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:33:32,200 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:33:32,200 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:33:58,590 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:33:31 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2833'), (b'content-type', b'application/json'), (b'x-process-time', b'26')])
2025-06-09 13:33:58,591 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:33:58,591 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:33:58,592 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:33:58,592 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:33:58,592 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:33:58,592 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:33:31 GMT', 'server': 'uvicorn', 'content-length': '2833', 'content-type': 'application/json', 'x-process-time': '26'})
2025-06-09 13:33:58,593 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:33:58,594 - root - DEBUG - 正在提取JSON，原始文本长度: 1400, 清理后长度: 1400
2025-06-09 13:33:58,594 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "main.c:<global>",
        "roles": [
          ...
2025-06-09 13:33:58,595 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 7 column 42 (char 179)
2025-06-09 13:33:58,595 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "main.c:<global>",
        "roles": [
          ...
2025-06-09 13:33:58,596 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 7 column 42 (char 179)
2025-06-09 13:33:58,596 - root - DEBUG - 模式 3 找到内容: c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    // 从命令行参数获取输入
    i...
2025-06-09 13:33:58,596 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "main.c:<global>",
        "roles": [
     ...
2025-06-09 13:33:58,597 - root - DEBUG - 找到嵌入JSON: []...
2025-06-09 13:33:58,598 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 26.40秒
2025-06-09 13:33:58,598 - CPGvulnHunter.bridges.llmWrapper - ERROR - LLM返回数据不是字典类型: <class 'list'>
2025-06-09 13:33:58,598 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:33:58,598 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: safe_sink\nFull Name: safe_sink\nSignature: void(int)\nFile: main.c\ncode: void safe_sink(int data) {\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "safe_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:33:58,598 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:33:58,601 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2af0739b-ce3f-443b-a539-a3915110448a', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: safe_sink\nFull Name: safe_sink\nSignature: void(int)\nFile: main.c\ncode: void safe_sink(int data) {\n    printf("SAFE SINK: Safely processed data: %d\\n", data);\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "safe_sink",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:33:58,602 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:33:58,603 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:33:58,603 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:33:58,603 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:33:58,604 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:33:58,604 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:34:13,903 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:33:57 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1773'), (b'content-type', b'application/json'), (b'x-process-time', b'15')])
2025-06-09 13:34:13,904 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:34:13,904 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:34:13,904 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:34:13,904 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:34:13,905 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:34:13,905 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:33:57 GMT', 'server': 'uvicorn', 'content-length': '1773', 'content-type': 'application/json', 'x-process-time': '15'})
2025-06-09 13:34:13,905 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:34:13,906 - root - DEBUG - 正在提取JSON，原始文本长度: 711, 清理后长度: 711
2025-06-09 13:34:13,907 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "safe_sink",
        "roles": [
            {
  ...
2025-06-09 13:34:13,907 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:34:13,907 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 15.31秒
2025-06-09 13:34:13,907 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:34:13,907 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:34:13,907 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: input\nFull Name: input\nSignature: char*()\nFile: main.c\ncode: char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:34:13,908 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:34:13,910 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d844deee-a898-428c-b7f7-bf45a7204385', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: input\nFull Name: input\nSignature: char*()\nFile: main.c\ncode: char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:34:13,911 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:34:13,912 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:34:13,912 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:34:13,912 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:34:13,913 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:34:13,913 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:34:32,588 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:34:13 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2101'), (b'content-type', b'application/json'), (b'x-process-time', b'19')])
2025-06-09 13:34:32,589 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:34:32,589 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:34:32,589 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:34:32,590 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:34:32,590 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:34:32,590 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:34:13 GMT', 'server': 'uvicorn', 'content-length': '2101', 'content-type': 'application/json', 'x-process-time': '19'})
2025-06-09 13:34:32,590 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:34:32,591 - root - DEBUG - 正在提取JSON，原始文本长度: 742, 清理后长度: 742
2025-06-09 13:34:32,592 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "input",
        "roles": [
            {
      ...
2025-06-09 13:34:32,592 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:34:32,592 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 18.68秒
2025-06-09 13:34:32,592 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:34:32,592 - root - INFO - 函数 input 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: 函数从标准输入读取数据并返回，这符合不受信任的用户输入的行为。
2025-06-09 13:34:32,593 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:34:32,593 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: main.c\ncode: int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:34:32,593 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:34:32,595 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-80a420e1-8126-4141-a229-667be6dbc9d5', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: main.c\ncode: int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:34:32,596 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:34:32,597 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:34:32,598 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:34:32,598 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:34:32,598 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:34:32,598 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:34:56,522 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:34:31 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2558'), (b'content-type', b'application/json'), (b'x-process-time', b'24')])
2025-06-09 13:34:56,523 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:34:56,523 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:34:56,524 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:34:56,524 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:34:56,524 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:34:56,524 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:34:31 GMT', 'server': 'uvicorn', 'content-length': '2558', 'content-type': 'application/json', 'x-process-time': '24'})
2025-06-09 13:34:56,524 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:34:56,526 - root - DEBUG - 正在提取JSON，原始文本长度: 1098, 清理后长度: 1098
2025-06-09 13:34:56,526 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "main",
        "roles": [
            {
       ...
2025-06-09 13:34:56,526 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:34:56,526 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 23.93秒
2025-06-09 13:34:56,527 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:34:56,527 - root - INFO - 函数 main 角色: SOURCE, 参数索引: -1, 置信度: 0.9, 理由: 函数通过调用 input() 函数获取用户输入，这是典型的不受信任的数据来源。
2025-06-09 13:34:56,527 - root - INFO - 函数 main 角色: SINK, 参数索引: 1, 置信度: 1.0, 理由: dangerous_sink(data) 函数是将数据传递给可能存在命令注入风险的函数或操作的地方。在没有更多关于 dangerous_sink() 的具体实现细节的情况下，我们可以假设这是一个潜在危险的操作。
2025-06-09 13:34:56,527 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:34:56,527 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:34:56,528 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:34:56,530 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2f4d1fa7-27d3-4dd9-b968-931bf9bea71d', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:34:56,531 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:34:56,532 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:34:56,532 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:34:56,532 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:34:56,533 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:34:56,533 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:35:06,972 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:34:55 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1426'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:35:06,973 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:35:06,973 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:35:06,973 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:35:06,973 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:35:06,974 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:35:06,974 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:34:55 GMT', 'server': 'uvicorn', 'content-length': '1426', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:35:06,974 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:35:06,975 - root - DEBUG - 正在提取JSON，原始文本长度: 355, 清理后长度: 355
2025-06-09 13:35:06,975 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "<includes>:<global>",
        "roles": []
    }...
2025-06-09 13:35:06,975 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:35:06,975 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 10.45秒
2025-06-09 13:35:06,976 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:35:06,976 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:35:06,976 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:35:06,976 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:35:06,978 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-43521716-7744-4458-8eda-4b358e3cebf7', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:35:06,979 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:35:06,979 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:35:06,980 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:35:06,980 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:35:06,980 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:35:06,981 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:35:14,075 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:35:06 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1067'), (b'content-type', b'application/json'), (b'x-process-time', b'8')])
2025-06-09 13:35:14,076 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:35:14,076 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:35:14,077 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:35:14,077 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:35:14,077 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:35:14,077 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:35:06 GMT', 'server': 'uvicorn', 'content-length': '1067', 'content-type': 'application/json', 'x-process-time': '8'})
2025-06-09 13:35:14,078 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:35:14,079 - root - DEBUG - 正在提取JSON，原始文本长度: 314, 清理后长度: 314
2025-06-09 13:35:14,079 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-09 13:35:14,079 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:35:14,079 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 7.10秒
2025-06-09 13:35:14,080 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:35:14,080 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:35:14,080 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:35:14,080 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:35:14,082 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-20623595-b7a9-4711-8586-b7290495ae57', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:35:14,084 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:35:14,084 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:35:14,085 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:35:14,085 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:35:14,085 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:35:14,085 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:35:24,410 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:35:13 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1386'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:35:24,411 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:35:24,411 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:35:24,412 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:35:24,412 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:35:24,412 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:35:24,412 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:35:13 GMT', 'server': 'uvicorn', 'content-length': '1386', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:35:24,413 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:35:24,414 - root - DEBUG - 正在提取JSON，原始文本长度: 534, 清理后长度: 534
2025-06-09 13:35:24,414 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-09 13:35:24,415 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:35:24,415 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 10.33秒
2025-06-09 13:35:24,415 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:35:24,415 - root - INFO - 函数 fgets 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: fgets函数从标准输入或指定的文件流中读取数据，如果该数据来源不可信，则可能成为命令注入攻击的数据源。
2025-06-09 13:35:24,415 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:35:24,415 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:35:24,416 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:35:24,418 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d30e90a8-c370-430f-baf7-c8b0ccf0df99', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strncpy\nFull Name: strncpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strncpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:35:24,419 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:35:24,420 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:35:24,420 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:35:24,421 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:35:24,421 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:35:24,421 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:35:40,169 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:35:23 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1889'), (b'content-type', b'application/json'), (b'x-process-time', b'16')])
2025-06-09 13:35:40,170 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:35:40,170 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:35:40,171 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:35:40,171 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:35:40,171 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:35:40,171 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:35:23 GMT', 'server': 'uvicorn', 'content-length': '1889', 'content-type': 'application/json', 'x-process-time': '16'})
2025-06-09 13:35:40,171 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:35:40,173 - root - DEBUG - 正在提取JSON，原始文本长度: 631, 清理后长度: 631
2025-06-09 13:35:40,173 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strncpy",
        "roles": [
            {
    ...
2025-06-09 13:35:40,173 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:35:40,174 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 15.76秒
2025-06-09 13:35:40,174 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:35:40,174 - CWE78 - INFO - 分析完成，找到 3 个源函数，1 个汇聚点函数，0 个清理函数
2025-06-09 13:35:40,174 - root - INFO - 找到 3 个源函数，1 个汇聚点函数，0 个清理函数
2025-06-09 13:35:40,174 - root - INFO - 源函数列表: ['input', 'main', 'fgets']
2025-06-09 13:35:40,174 - root - INFO - 汇聚点函数列表: ['main']
2025-06-09 13:35:40,175 - root - INFO - 清理函数列表: []
2025-06-09 13:35:40,175 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("input").methodReturn).toJsonPretty...
2025-06-09 13:35:40,664 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("input").methodReturn).toJsonPretty
>val res22: String = """[
  
]"""
=~...
2025-06-09 13:35:40,664 - root - INFO - 分析源 input 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='input', ast_parent_full_name='main.c:<global>', ast_parent_type='TYPE_DECL', code='char* input() {\n    char data[100];\n    fgets(data,100,stdin);\n    return data;\n}', column_number=1, column_number_end=1, filename='main.c', full_name='input', generic_signature='<empty>', hash_value=None, is_external=False, line_number=18, line_number_end=22, offset=None, offset_end=None, order=1, signature='char*()', parameters=None, useage=None, index=-1), sink=Sink(name='main', ast_parent_full_name='main.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}', column_number=1, column_number_end=1, filename='main.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=24, line_number_end=33, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:35:40,665 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:35:41,020 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("main").methodReturn).toJsonPretty
>val res23: String = """[
  
]"""
=~...
2025-06-09 13:35:41,020 - root - INFO - 分析源 main 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='main.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}', column_number=1, column_number_end=1, filename='main.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=24, line_number_end=33, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='main', ast_parent_full_name='main.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n    printf("=== 数据流传播测试 ===\\n");\n    char* ptr;\n    char data[256];\n    ptr = input();\n    strncpy(data, ptr, sizeof(data) - 1);\n    dangerous_sink(data);\n    // memcpy(user_data, const void *, unsigned long) // This line is incomplete and should be removed or fixed\n\n}', column_number=1, column_number_end=1, filename='main.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=24, line_number_end=33, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:35:41,021 - root - ERROR - 分析源 fgets 到汇聚点 main 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO - Pass cwe78 执行成功，耗时: 152.24秒
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO - ✓ Pass cwe78 执行成功
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO - 
============================================================
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-09 13:35:41,021 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 总耗时: 226.45秒
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 成功的passes: 2
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO -   - init: 成功 (74.21s, 0个发现)
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO -   - cwe78: 成功 (152.24s, 0个发现)
2025-06-09 13:35:41,022 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-09 13:35:41,024 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250609_133541.json
2025-06-09 13:41:23,544 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:41:23,544 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-09 13:41:23,544 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-09 13:41:23,544 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-09 13:41:23,545 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-09 13:41:23,545 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-09 13:41:23,545 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-09 13:41:23,545 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:41:23,545 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:41:23,545 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-09 13:41:23,545 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-09 13:41:23,545 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-09 13:41:23,545 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-09 13:41:28,445 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-09 13:41:28,446 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-09 13:41:28,446 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-09 13:41:28,446 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-09 13:41:28,446 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-09 13:41:28,497 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.05秒
2025-06-09 13:41:28,497 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-09 13:41:28,497 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-09 13:41:28,497 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-09 13:41:28,497 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:41:28,497 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test2")...
2025-06-09 13:41:31,027 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test2")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test21` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test2`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test2 --output /home/nstl/data/CPGvulnHunter/workspace/test21/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test21/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[397 nodes]]
=~...
2025-06-09 13:41:31,028 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.53秒
2025-06-09 13:41:31,028 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-09 13:41:31,028 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.48秒
2025-06-09 13:41:31,028 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-09 13:41:31,028 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-09 13:41:31,028 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-09 13:41:31,029 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-09 13:41:31,029 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-09 13:41:31,029 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-09 13:41:31,029 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-09 13:41:31,029 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:41:31,029 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO - 分析配置:
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-09 13:41:31,030 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-09 13:41:31,031 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-09 13:41:31,736 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "get_user_input",
  "command.c:<global>",
  "basic_validate",
  "execute_command",
  "list_files",
  "main",
  "<includes>:<global>",
  "<operator>.assignment",
  "<operator>.alloc",
  "command.c:6:6:MAX_BUFFER:0",
  "printf",
  "fgets",
  "<operator>.sizeOf",
  "strlen",
  "<operator>.logicalAnd",
  "<operator>.greaterThan",
  "<operator>.equals",
  "<operator>.indirectIndexAccess",
  "<operator>.subtraction",
  "strcpy",
  "<operator>.arrayInitializer",
  "<operator>.division",
  "<operator>.lessThan",
  "<operator>.postIncrement",
  "strstr",
  "memset",
  "system",
  "snprintf",
  "popen",
  "pclose"
]"""
=~...
2025-06-09 13:41:31,737 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total function full names found: 30
2025-06-09 13:41:31,737 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("get_user_input").toJsonPretty...
2025-06-09 13:41:32,138 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("get_user_input").toJsonPretty
>val res2: String = """[
  {
    "name":"get_user_input",
    "astParentFullName":"command.c:<global>",
    "_id":111669149696,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":25,
    "_label":"METHOD",
    "columnNumberEnd":29,
    "fullName":"get_user_input",
    "genericSignature":"<empty>",
    "code":"char* get_user_input() {\n    static char input_buffer[MAX_BUFFER];\n    printf(\"请输入文件名: \");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == '\\n') {\n        input_buffer[len-1] = '\\0';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}",
    "isExternal":false,
    "lineNumber":13,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:32,139 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:<global>").toJsonPretty...
2025-06-09 13:41:32,525 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"command.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":72,
    "_label":"METHOD",
    "columnNumberEnd":29,
    "fullName":"command.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:32,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("basic_validate").toJsonPretty...
2025-06-09 13:41:32,920 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("basic_validate").toJsonPretty
>val res4: String = """[
  {
    "name":"basic_validate",
    "astParentFullName":"command.c:<global>",
    "_id":111669149698,
    "signature":"char*(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":42,
    "_label":"METHOD",
    "columnNumberEnd":26,
    "fullName":"basic_validate",
    "genericSignature":"<empty>",
    "code":"char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {\"rm\", \"del\"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, 'X', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}",
    "isExternal":false,
    "lineNumber":27,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:32,921 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").toJsonPretty...
2025-06-09 13:41:33,295 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").toJsonPretty
>val res5: String = """[
  {
    "name":"execute_command",
    "astParentFullName":"command.c:<global>",
    "_id":111669149699,
    "signature":"void(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":48,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"execute_command",
    "genericSignature":"<empty>",
    "code":"void execute_command(char* command) {\n    printf(\"执行命令: %s\\n\", command);\n    system(command);  \n}",
    "isExternal":false,
    "lineNumber":45,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:33,296 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").toJsonPretty...
2025-06-09 13:41:33,646 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").toJsonPretty
>val res6: String = """[
  {
    "name":"list_files",
    "astParentFullName":"command.c:<global>",
    "_id":111669149700,
    "signature":"void(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":63,
    "_label":"METHOD",
    "columnNumberEnd":22,
    "fullName":"list_files",
    "genericSignature":"<empty>",
    "code":"void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), \"ls %s\", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, \"r\");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf(\"文件: %s\", output);\n        }\n        pclose(pipe);\n    }\n}",
    "isExternal":false,
    "lineNumber":51,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:33,647 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-09 13:41:34,007 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res7: String = """[
  {
    "name":"main",
    "astParentFullName":"command.c:<global>",
    "_id":111669149701,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":72,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}",
    "isExternal":false,
    "lineNumber":65,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:34,007 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-09 13:41:34,358 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res8: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-09 13:41:34,358 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-09 13:41:34,699 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res9: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:34,699 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-09 13:41:35,058 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res10: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:35,058 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").toJsonPretty...
2025-06-09 13:41:35,419 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").toJsonPretty
>val res11: String = """[
  {
    "name":"MAX_BUFFER",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "lineNumberEnd":6,
    "_label":"METHOD",
    "fullName":"command.c:6:6:MAX_BUFFER:0",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "lineNumber":6,
    "order":0,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:41:35,420 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").parameter.toJsonPretty...
2025-06-09 13:41:35,787 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").parameter.toJsonPretty
>val res12: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p0",
    "_id":115964116998,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":0,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":0,
    "code":"p0"
  }
]"""
=~...
2025-06-09 13:41:36,188 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 的使用情况: ['input_buffer[MAX_BUFFER]', 'validated[MAX_BUFFER]', 'full_command[MAX_BUFFER]']
2025-06-09 13:41:36,188 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-09 13:41:36,518 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res14: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:36,518 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-09 13:41:36,882 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res15: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:41:37,238 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}', '{\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', '{\n            printf("文件: %s", output);\n        }']
2025-06-09 13:41:37,238 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-09 13:41:37,563 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res17: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:37,563 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-09 13:41:37,907 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res18: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:41:38,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}', 'while (fgets(output, sizeof(output), pipe))']
2025-06-09 13:41:38,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-09 13:41:38,586 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:38,586 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strlen").toJsonPretty...
2025-06-09 13:41:38,959 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strlen").toJsonPretty
>val res21: String = """[
  {
    "name":"strlen",
    "astParentFullName":"<global>",
    "_id":111669149709,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strlen",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:38,960 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strlen").parameter.toJsonPretty...
2025-06-09 13:41:39,279 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strlen").parameter.toJsonPretty
>val res22: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117005,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:41:39,629 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strlen 的使用情况: ['len = strlen(input_buffer)', "memset(pos, 'X', strlen(dangerous[i]))"]
2025-06-09 13:41:39,629 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.logicalAnd").toJsonPretty...
2025-06-09 13:41:39,963 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.logicalAnd").toJsonPretty
>val res24: String = """[
  {
    "name":"<operator>.logicalAnd",
    "astParentFullName":"<global>",
    "_id":111669149710,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.logicalAnd",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:39,963 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.greaterThan").toJsonPretty...
2025-06-09 13:41:40,265 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.greaterThan").toJsonPretty
>val res25: String = """[
  {
    "name":"<operator>.greaterThan",
    "astParentFullName":"<global>",
    "_id":111669149711,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.greaterThan",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:40,265 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.equals").toJsonPretty...
2025-06-09 13:41:40,593 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.equals").toJsonPretty
>val res26: String = """[
  {
    "name":"<operator>.equals",
    "astParentFullName":"<global>",
    "_id":111669149712,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.equals",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:40,594 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.indirectIndexAccess").toJsonPretty...
2025-06-09 13:41:40,926 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.indirectIndexAccess").toJsonPretty
>val res27: String = """[
  {
    "name":"<operator>.indirectIndexAccess",
    "astParentFullName":"<global>",
    "_id":111669149713,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.indirectIndexAccess",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:40,927 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-09 13:41:41,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res28: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149714,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:41,242 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strcpy").toJsonPretty...
2025-06-09 13:41:41,572 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strcpy").toJsonPretty
>val res29: String = """[
  {
    "name":"strcpy",
    "astParentFullName":"<global>",
    "_id":111669149715,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strcpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:41,573 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strcpy").parameter.toJsonPretty...
2025-06-09 13:41:41,901 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strcpy").parameter.toJsonPretty
>val res30: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117016,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117017,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:41:42,242 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strcpy 的使用情况: ['{\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}']
2025-06-09 13:41:42,242 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.arrayInitializer").toJsonPretty...
2025-06-09 13:41:42,559 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.arrayInitializer").toJsonPretty
>val res32: String = """[
  {
    "name":"<operator>.arrayInitializer",
    "astParentFullName":"<global>",
    "_id":111669149716,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.arrayInitializer",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:42,559 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.division").toJsonPretty...
2025-06-09 13:41:42,883 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.division").toJsonPretty
>val res33: String = """[
  {
    "name":"<operator>.division",
    "astParentFullName":"<global>",
    "_id":111669149717,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.division",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:42,884 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.lessThan").toJsonPretty...
2025-06-09 13:41:43,196 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.lessThan").toJsonPretty
>val res34: String = """[
  {
    "name":"<operator>.lessThan",
    "astParentFullName":"<global>",
    "_id":111669149718,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.lessThan",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:43,196 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.postIncrement").toJsonPretty...
2025-06-09 13:41:43,502 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.postIncrement").toJsonPretty
>val res35: String = """[
  {
    "name":"<operator>.postIncrement",
    "astParentFullName":"<global>",
    "_id":111669149719,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.postIncrement",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:43,502 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strstr").toJsonPretty...
2025-06-09 13:41:43,815 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strstr").toJsonPretty
>val res36: String = """[
  {
    "name":"strstr",
    "astParentFullName":"<global>",
    "_id":111669149720,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strstr",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:43,815 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strstr").parameter.toJsonPretty...
2025-06-09 13:41:44,133 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strstr").parameter.toJsonPretty
>val res37: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117025,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117026,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:41:44,456 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strstr 的使用情况: ['* pos = strstr(validated, dangerous[i])']
2025-06-09 13:41:44,456 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("memset").toJsonPretty...
2025-06-09 13:41:44,759 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("memset").toJsonPretty
>val res39: String = """[
  {
    "name":"memset",
    "astParentFullName":"<global>",
    "_id":111669149721,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"memset",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:44,760 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("memset").parameter.toJsonPretty...
2025-06-09 13:41:45,077 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("memset").parameter.toJsonPretty
>val res40: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117027,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117028,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117029,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:41:45,395 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 memset 的使用情况: ["{\n            memset(pos, 'X', strlen(dangerous[i]));\n        }"]
2025-06-09 13:41:45,395 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").toJsonPretty...
2025-06-09 13:41:45,715 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").toJsonPretty
>val res42: String = """[
  {
    "name":"system",
    "astParentFullName":"<global>",
    "_id":111669149722,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"system",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:45,715 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.toJsonPretty...
2025-06-09 13:41:46,039 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.toJsonPretty
>val res43: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117030,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:41:46,359 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 system 的使用情况: ['{\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}']
2025-06-09 13:41:46,359 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("snprintf").toJsonPretty...
2025-06-09 13:41:46,671 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("snprintf").toJsonPretty
>val res45: String = """[
  {
    "name":"snprintf",
    "astParentFullName":"<global>",
    "_id":111669149723,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"snprintf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:46,672 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("snprintf").parameter.toJsonPretty...
2025-06-09 13:41:46,987 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("snprintf").parameter.toJsonPretty
>val res46: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117031,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117032,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117033,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p4",
    "_id":115964117034,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":4,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":4,
    "code":"p4"
  }
]"""
=~...
2025-06-09 13:41:47,345 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 snprintf 的使用情况: ['{\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}']
2025-06-09 13:41:47,346 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").toJsonPretty...
2025-06-09 13:41:47,670 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").toJsonPretty
>val res48: String = """[
  {
    "name":"popen",
    "astParentFullName":"<global>",
    "_id":111669149724,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"popen",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:47,670 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.toJsonPretty...
2025-06-09 13:41:47,995 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.toJsonPretty
>val res49: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117035,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117036,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:41:48,400 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 popen 的使用情况: ['* pipe = popen(full_command, "r")']
2025-06-09 13:41:48,401 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("pclose").toJsonPretty...
2025-06-09 13:41:48,714 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("pclose").toJsonPretty
>val res51: String = """[
  {
    "name":"pclose",
    "astParentFullName":"<global>",
    "_id":111669149725,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"pclose",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:41:48,714 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("pclose").parameter.toJsonPretty...
2025-06-09 13:41:49,014 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("pclose").parameter.toJsonPretty
>val res52: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117037,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:41:49,349 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 pclose 的使用情况: ['{\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }']
2025-06-09 13:41:49,349 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 18
2025-06-09 13:41:49,349 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 11
2025-06-09 13:41:49,349 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 7
2025-06-09 13:41:49,349 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 12
2025-06-09 13:41:49,350 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 11 个外部函数
2025-06-09 13:41:49,350 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/11: command.c:6:6:MAX_BUFFER:0
2025-06-09 13:41:49,350 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: command.c:6:6:MAX_BUFFER:0
2025-06-09 13:41:49,350 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 command.c:6:6:MAX_BUFFER:0 构建分析请求完成
2025-06-09 13:41:49,350 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: command.c:6:6:MAX_BUFFER:0\n函数签名: 未知签名\n函数用法: [\'input_buffer[MAX_BUFFER]\', \'validated[MAX_BUFFER]\', \'full_command[MAX_BUFFER]\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "command.c:6:6:MAX_BUFFER:0",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:41:49,351 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:41:49,537 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-b333d8c6-0c0a-46ae-83d4-e6c3a8145be7', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: command.c:6:6:MAX_BUFFER:0\n函数签名: 未知签名\n函数用法: [\'input_buffer[MAX_BUFFER]\', \'validated[MAX_BUFFER]\', \'full_command[MAX_BUFFER]\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "command.c:6:6:MAX_BUFFER:0",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:41:49,540 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:41:49,541 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-09 13:41:49,542 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x78860903c110>
2025-06-09 13:41:49,542 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:41:49,543 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:41:49,543 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:41:49,543 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:41:49,543 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:42:31,445 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:41:49 GMT'), (b'server', b'uvicorn'), (b'content-length', b'921'), (b'content-type', b'application/json'), (b'x-process-time', b'42')])
2025-06-09 13:42:31,446 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:42:31,446 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:42:31,447 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:42:31,447 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:42:31,447 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:42:31,447 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:41:49 GMT', 'server': 'uvicorn', 'content-length': '921', 'content-type': 'application/json', 'x-process-time': '42'})
2025-06-09 13:42:31,447 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:42:31,449 - root - DEBUG - 正在提取JSON，原始文本长度: 194, 清理后长度: 194
2025-06-09 13:42:31,450 - root - DEBUG - 直接解析成功
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 LLM请求完成，耗时: 42.10秒
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 原始参数流数据: []
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 command.c:6:6:MAX_BUFFER:0 语义规则生成成功 - 参数流数量: 0, 置信度: high
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 分析依据: 根据提供的函数用法信息，未发现明确的数据流模式。
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 command.c:6:6:MAX_BUFFER:0 分析成功，耗时: 42.10秒
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/11: printf
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-09 13:42:31,450 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-09 13:42:31,450 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\', \'{\\n            printf("文件: %s", output);\\n        }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:42:31,450 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:42:31,451 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-05383e18-c192-4891-b405-078725e80d2f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\', \'{\\n            printf("文件: %s", output);\\n        }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:42:31,452 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:42:31,452 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:42:31,453 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:42:31,453 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:42:31,453 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:42:31,453 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:42:47,569 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:42:30 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1373'), (b'content-type', b'application/json'), (b'x-process-time', b'16')])
2025-06-09 13:42:47,570 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:42:47,570 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:42:47,570 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:42:47,570 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:42:47,570 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:42:47,571 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:42:30 GMT', 'server': 'uvicorn', 'content-length': '1373', 'content-type': 'application/json', 'x-process-time': '16'})
2025-06-09 13:42:47,571 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:42:47,571 - root - DEBUG - 正在提取JSON，原始文本长度: 402, 清理后长度: 402
2025-06-09 13:42:47,572 - root - DEBUG - 直接解析成功
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 16.12秒
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: 根据提供的用法示例，'printf'函数的第二个参数（格式化字符串中的占位符）可能包含来自用户输入的数据，并将其传递给后续的操作中使用。例如，在'printf("执行命令: %s\n", command);'中，command变量作为第二个参数，其值被输出到控制台，并且在system(command)调用时被执行。因此，'printf'函数中的格式化字符串数据从源（如用户输入或其他变量）流向后续操作或返回值。
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 16.12秒
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/11: fgets
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-09 13:42:47,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-09 13:42:47,572 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'while (fgets(output, sizeof(output), pipe))\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:42:47,572 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:42:47,573 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-c234acaf-358a-49a3-8862-7f29b36b6cd3', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'while (fgets(output, sizeof(output), pipe))\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:42:47,574 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:42:47,575 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:42:47,575 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:42:47,575 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:42:47,575 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:42:47,575 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:42:59,211 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:42:46 GMT'), (b'server', b'uvicorn'), (b'content-length', b'950'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-09 13:42:59,212 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:42:59,212 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:42:59,212 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:42:59,212 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:42:59,213 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:42:59,213 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:42:46 GMT', 'server': 'uvicorn', 'content-length': '950', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-09 13:42:59,213 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:42:59,214 - root - DEBUG - 正在提取JSON，原始文本长度: 224, 清理后长度: 224
2025-06-09 13:42:59,214 - root - DEBUG - 直接解析成功
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 11.64秒
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 函数fgets从文件流(参数3)读取数据并存入目标缓冲区(参数1)
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 11.64秒
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 4/11: strlen
2025-06-09 13:42:59,214 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strlen
2025-06-09 13:42:59,215 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strlen 构建分析请求完成
2025-06-09 13:42:59,215 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strlen\n函数签名: 未知签名\n函数用法: [\'len = strlen(input_buffer)\', "memset(pos, \'X\', strlen(dangerous[i]))"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strlen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:42:59,215 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:42:59,216 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-e84d52ea-a823-4bba-8a26-b56b1fa48f7f', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strlen\n函数签名: 未知签名\n函数用法: [\'len = strlen(input_buffer)\', "memset(pos, \'X\', strlen(dangerous[i]))"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strlen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:42:59,217 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:42:59,217 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:42:59,218 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:42:59,218 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:42:59,218 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:42:59,218 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:43:08,848 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:42:58 GMT'), (b'server', b'uvicorn'), (b'content-length', b'938'), (b'content-type', b'application/json'), (b'x-process-time', b'9')])
2025-06-09 13:43:08,849 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:43:08,849 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:43:08,849 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:43:08,849 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:43:08,849 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:43:08,849 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:42:58 GMT', 'server': 'uvicorn', 'content-length': '938', 'content-type': 'application/json', 'x-process-time': '9'})
2025-06-09 13:43:08,849 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:43:08,850 - root - DEBUG - 正在提取JSON，原始文本长度: 192, 清理后长度: 192
2025-06-09 13:43:08,850 - root - DEBUG - 直接解析成功
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen LLM请求完成，耗时: 9.64秒
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen 原始参数流数据: []
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strlen 语义规则生成成功 - 参数流数量: 0, 置信度: high
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen 分析依据: strlen函数不涉及参数之间的数据传递关系，其主要作用是计算字符串长度并返回结果。
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strlen 分析成功，耗时: 9.64秒
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 5/11: strcpy
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strcpy
2025-06-09 13:43:08,850 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strcpy 构建分析请求完成
2025-06-09 13:43:08,850 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strcpy\n函数签名: 未知签名\n函数用法: [\'{\\n    static char validated[MAX_BUFFER];\\n    strcpy(validated, input);\\n    \\n    char* dangerous[] = {"rm", "del"};\\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\\n    \\n    for (int i = 0; i < dangerous_count; i++) {\\n        char* pos = strstr(validated, dangerous[i]);\\n        if (pos) {\\n            memset(pos, \\\'X\\\', strlen(dangerous[i]));\\n        }\\n    }\\n    \\n    return validated;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strcpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:43:08,850 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:43:08,851 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-ddb0b0f9-9978-4a66-8b17-0ebccf5b2446', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strcpy\n函数签名: 未知签名\n函数用法: [\'{\\n    static char validated[MAX_BUFFER];\\n    strcpy(validated, input);\\n    \\n    char* dangerous[] = {"rm", "del"};\\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\\n    \\n    for (int i = 0; i < dangerous_count; i++) {\\n        char* pos = strstr(validated, dangerous[i]);\\n        if (pos) {\\n            memset(pos, \\\'X\\\', strlen(dangerous[i]));\\n        }\\n    }\\n    \\n    return validated;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strcpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:43:08,852 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:43:08,852 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:43:08,852 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:43:08,852 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:43:08,852 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:43:08,852 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:43:20,287 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:43:08 GMT'), (b'server', b'uvicorn'), (b'content-length', b'959'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-09 13:43:20,287 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:43:20,288 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:43:20,288 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:43:20,288 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:43:20,288 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:43:20,289 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:43:08 GMT', 'server': 'uvicorn', 'content-length': '959', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-09 13:43:20,289 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:43:20,290 - root - DEBUG - 正在提取JSON，原始文本长度: 229, 清理后长度: 229
2025-06-09 13:43:20,290 - root - DEBUG - 直接解析成功
2025-06-09 13:43:20,290 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy LLM请求完成，耗时: 11.44秒
2025-06-09 13:43:20,290 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 添加参数流 1: 2 -> 1
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strcpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 分析依据: strcpy函数将输入参数src的数据流向dest，这是其典型数据流模式。
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strcpy 分析成功，耗时: 11.44秒
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 6/11: strstr
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strstr
2025-06-09 13:43:20,291 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strstr 构建分析请求完成
2025-06-09 13:43:20,291 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strstr\n函数签名: 未知签名\n函数用法: [\'* pos = strstr(validated, dangerous[i])\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strstr",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:43:20,292 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:43:20,293 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-0a27c7b9-d50a-4e34-8ac3-246707eda39a', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strstr\n函数签名: 未知签名\n函数用法: [\'* pos = strstr(validated, dangerous[i])\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strstr",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:43:20,295 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:43:20,295 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:43:20,296 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:43:20,296 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:43:20,296 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:43:20,296 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:43:30,832 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:43:19 GMT'), (b'server', b'uvicorn'), (b'content-length', b'992'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:43:30,832 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:43:30,833 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:43:30,833 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:43:30,833 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:43:30,834 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:43:30,834 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:43:19 GMT', 'server': 'uvicorn', 'content-length': '992', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:43:30,834 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:43:30,835 - root - DEBUG - 正在提取JSON，原始文本长度: 244, 清理后长度: 244
2025-06-09 13:43:30,836 - root - DEBUG - 直接解析成功
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr LLM请求完成，耗时: 10.54秒
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 添加参数流 1: 2 -> -1
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strstr 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 分析依据: 函数strstr的第二个参数dangerous[i]的数据流向了返回值，即从模式字符串参数流向结果位置
2025-06-09 13:43:30,836 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strstr 分析成功，耗时: 10.55秒
2025-06-09 13:43:30,837 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 7/11: memset
2025-06-09 13:43:30,837 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: memset
2025-06-09 13:43:30,837 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 memset 构建分析请求完成
2025-06-09 13:43:30,837 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: memset\n函数签名: 未知签名\n函数用法: ["{\\n            memset(pos, \'X\', strlen(dangerous[i]));\\n        }"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "memset",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:43:30,837 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:43:30,839 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-4412923f-bc38-4ad2-b78b-84b9102b50f9', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: memset\n函数签名: 未知签名\n函数用法: ["{\\n            memset(pos, \'X\', strlen(dangerous[i]));\\n        }"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "memset",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:43:30,841 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:43:30,841 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:43:30,842 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:43:30,842 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:43:30,842 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:43:30,842 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:43:41,048 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:43:30 GMT'), (b'server', b'uvicorn'), (b'content-length', b'942'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:43:41,048 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:43:41,049 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:43:41,049 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:43:41,049 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:43:41,050 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:43:41,050 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:43:30 GMT', 'server': 'uvicorn', 'content-length': '942', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:43:41,050 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:43:41,051 - root - DEBUG - 正在提取JSON，原始文本长度: 216, 清理后长度: 216
2025-06-09 13:43:41,052 - root - DEBUG - 直接解析成功
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset LLM请求完成，耗时: 10.21秒
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 添加参数流 1: 2 -> 1
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 memset 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 分析依据: 数据从参数2流向参数1，即源字符流向目标缓冲区。
2025-06-09 13:43:41,052 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 memset 分析成功，耗时: 10.22秒
2025-06-09 13:43:41,053 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 8/11: system
2025-06-09 13:43:41,053 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: system
2025-06-09 13:43:41,053 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 system 构建分析请求完成
2025-06-09 13:43:41,053 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: system\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "system",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:43:41,053 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:43:41,055 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-049ec5d9-5b39-4ea0-93e3-8f606094f0d5', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: system\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "system",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:43:41,057 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:43:41,058 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:43:41,058 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:43:41,058 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:43:41,059 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:43:41,059 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:43:51,119 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:43:40 GMT'), (b'server', b'uvicorn'), (b'content-length', b'963'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:43:51,120 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:43:51,120 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:43:51,121 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:43:51,121 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:43:51,121 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:43:51,121 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:43:40 GMT', 'server': 'uvicorn', 'content-length': '963', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:43:51,121 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:43:51,123 - root - DEBUG - 正在提取JSON，原始文本长度: 227, 清理后长度: 227
2025-06-09 13:43:51,123 - root - DEBUG - 直接解析成功
2025-06-09 13:43:51,123 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 system LLM请求完成，耗时: 10.07秒
2025-06-09 13:43:51,123 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 system 原始参数流数据: [{'from': 1, 'to': -1}]
2025-06-09 13:43:51,123 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 system 添加参数流 1: 1 -> -1
2025-06-09 13:43:51,123 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 system 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:43:51,124 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 system 分析依据: system函数接收命令字符串作为参数，该参数直接用于执行系统命令。
2025-06-09 13:43:51,124 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 system 分析成功，耗时: 10.07秒
2025-06-09 13:43:51,124 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 9/11: snprintf
2025-06-09 13:43:51,124 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: snprintf
2025-06-09 13:43:51,124 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 snprintf 构建分析请求完成
2025-06-09 13:43:51,124 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: snprintf\n函数签名: 未知签名\n函数用法: [\'{\\n    char full_command[MAX_BUFFER];\\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\\n    \\n    FILE* pipe = popen(full_command, "r");\\n    if (pipe) {\\n        char output[256];\\n        while (fgets(output, sizeof(output), pipe)) {\\n            printf("文件: %s", output);\\n        }\\n        pclose(pipe);\\n    }\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "snprintf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:43:51,125 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:43:51,127 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d2f286c8-18cf-4bab-b553-2f705e19df87', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: snprintf\n函数签名: 未知签名\n函数用法: [\'{\\n    char full_command[MAX_BUFFER];\\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\\n    \\n    FILE* pipe = popen(full_command, "r");\\n    if (pipe) {\\n        char output[256];\\n        while (fgets(output, sizeof(output), pipe)) {\\n            printf("文件: %s", output);\\n        }\\n        pclose(pipe);\\n    }\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "snprintf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:43:51,128 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:43:51,128 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:43:51,129 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:43:51,129 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:43:51,129 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:43:51,130 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:44:02,288 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:43:50 GMT'), (b'server', b'uvicorn'), (b'content-length', b'966'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:44:02,289 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:44:02,289 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:44:02,289 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:44:02,290 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:44:02,290 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:44:02,290 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:43:50 GMT', 'server': 'uvicorn', 'content-length': '966', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:44:02,290 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:44:02,292 - root - DEBUG - 正在提取JSON，原始文本长度: 236, 清理后长度: 236
2025-06-09 13:44:02,292 - root - DEBUG - 直接解析成功
2025-06-09 13:44:02,292 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 snprintf LLM请求完成，耗时: 11.17秒
2025-06-09 13:44:02,292 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 snprintf 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-09 13:44:02,292 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 snprintf 添加参数流 1: 3 -> 1
2025-06-09 13:44:02,292 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 snprintf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:44:02,293 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 snprintf 分析依据: 根据函数签名和用法，参数3（path）的数据流向参数1（full_command）。
2025-06-09 13:44:02,293 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 snprintf 分析成功，耗时: 11.17秒
2025-06-09 13:44:02,293 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 10/11: popen
2025-06-09 13:44:02,293 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: popen
2025-06-09 13:44:02,293 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 popen 构建分析请求完成
2025-06-09 13:44:02,293 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: popen\n函数签名: 未知签名\n函数用法: [\'* pipe = popen(full_command, "r")\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "popen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:44:02,294 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:44:02,296 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-0bf376fb-f2be-4bb9-9dc6-f94413250406', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: popen\n函数签名: 未知签名\n函数用法: [\'* pipe = popen(full_command, "r")\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "popen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:44:02,297 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:44:02,297 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:44:02,298 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:44:02,298 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:44:02,298 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:44:02,299 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:44:13,052 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:44:01 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1000'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:44:13,053 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:44:13,053 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:44:13,053 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:44:13,054 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:44:13,054 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:44:13,054 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:44:01 GMT', 'server': 'uvicorn', 'content-length': '1000', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:44:13,054 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:44:13,056 - root - DEBUG - 正在提取JSON，原始文本长度: 238, 清理后长度: 238
2025-06-09 13:44:13,056 - root - DEBUG - 直接解析成功
2025-06-09 13:44:13,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 popen LLM请求完成，耗时: 10.76秒
2025-06-09 13:44:13,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 popen 原始参数流数据: [{'from': 1, 'to': -1}]
2025-06-09 13:44:13,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 popen 添加参数流 1: 1 -> -1
2025-06-09 13:44:13,056 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 popen 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:44:13,057 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 popen 分析依据: popen函数的第1个参数（命令字符串）流向返回值，表示执行命令后打开管道供后续读取或写入。
2025-06-09 13:44:13,057 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 popen 分析成功，耗时: 10.76秒
2025-06-09 13:44:13,057 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 11/11: pclose
2025-06-09 13:44:13,057 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: pclose
2025-06-09 13:44:13,057 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 pclose 构建分析请求完成
2025-06-09 13:44:13,057 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: pclose\n函数签名: 未知签名\n函数用法: [\'{\\n        char output[256];\\n        while (fgets(output, sizeof(output), pipe)) {\\n            printf("文件: %s", output);\\n        }\\n        pclose(pipe);\\n    }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "pclose",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:44:13,058 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:44:13,060 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-3e1cc4e1-2e41-4a50-9e52-6d2e110acb37', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: pclose\n函数签名: 未知签名\n函数用法: [\'{\\n        char output[256];\\n        while (fgets(output, sizeof(output), pipe)) {\\n            printf("文件: %s", output);\\n        }\\n        pclose(pipe);\\n    }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "pclose",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:44:13,061 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:44:13,062 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:44:13,062 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:44:13,062 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:44:13,063 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:44:13,063 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:44:24,053 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:44:12 GMT'), (b'server', b'uvicorn'), (b'content-length', b'991'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:44:24,054 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:44:24,054 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:44:24,054 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:44:24,054 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:44:24,055 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:44:24,055 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:44:12 GMT', 'server': 'uvicorn', 'content-length': '991', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:44:24,055 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:44:24,056 - root - DEBUG - 正在提取JSON，原始文本长度: 209, 清理后长度: 209
2025-06-09 13:44:24,056 - root - DEBUG - 直接解析成功
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 pclose LLM请求完成，耗时: 11.00秒
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 pclose 原始参数流数据: []
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 pclose 语义规则生成成功 - 参数流数量: 0, 置信度: high
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 pclose 分析依据: pclose函数主要用于关闭一个管道文件流，并且不会从参数中读取或写入任何数据。因此，没有相关的数据流动路径需要记录。
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 pclose 分析成功，耗时: 11.00秒
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - INFO - 所有函数分析完成 - 成功: 11, 失败: 0, 总耗时: 154.71秒
2025-06-09 13:44:24,056 - CPGvulnHunter.bridges.llmWrapper - INFO - 总共生成 11 条语义规则
2025-06-09 13:44:24,057 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 开始应用语义规则...
2025-06-09 13:44:24,374 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.*...
2025-06-09 13:44:24,662 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.*
>=~...
2025-06-09 13:44:24,662 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.semanticsloader.*...
2025-06-09 13:44:24,952 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.semanticsloader.*
>=~...
2025-06-09 13:44:24,952 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: import io.joern.dataflowengineoss.queryengine.*...
2025-06-09 13:44:25,242 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: import io.joern.dataflowengineoss.queryengine.*
>=~...
2025-06-09 13:44:25,242 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: val extraFlows = List(FlowSemantic.from("command.c:6:6:MAX_BUFFER:0", List(), regex = false),
FlowSemantic.from("printf", List((2, -1)), regex = false),
FlowSemantic.from("fgets", List((3, 1)), regex = false),
FlowSemantic.from("strlen", List(), regex = false),
FlowSemantic.from("strcpy", List((2, 1)), regex = false),
FlowSemantic.from("strstr", List((2, -1)), regex = false),
FlowSemantic.from("memset", List((2, 1)), regex = false),
FlowSemantic.from("system", List((1, -1)), regex = false),
FlowSemantic.from("snprintf", List((3, 1)), regex = false),
FlowSemantic.from("popen", List((1, -1)), regex = false),
FlowSemantic.from("pclose", List(), regex = false))...
2025-06-09 13:44:25,774 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: val extraFlows = List(FlowSemantic.from("command.c:6:6:MAX_BUFFER:0", Lis
st(), regex = false),
     | FlowSemantic.from("printf", List((2, -1)), regex = false),
     | FlowSemantic.from("fgets", List((3, 1)), regex = false),
     | FlowSemantic.from("strlen", List(), regex = false),
     | FlowSemantic.from("strcpy", List((2, 1)), regex = false),
     | FlowSemantic.from("strstr", List((2, -1)), regex = false),
     | FlowSemantic.from("memset", List((2, 1)), regex = false),
     | FlowSemantic.from("system", List((1, -1)), regex = false),
     | FlowSemantic.from("snprintf", List((3, 1)), regex = false),
     | FlowSemantic.from("popen", List((1, -1)), regex = false),
     | FlowSemantic.from("pclose", List(), regex = false))
>val extraFlows: List[io.joern.dataflowengineoss.semanticsloader.FlowSemantic] = List(
  FlowSemantic(methodFullName = "command.c:6:6:MAX_BUFFER:0", mappings = List(), regex = false),
  FlowSemantic(
    methodFullName = "printf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "fgets",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(methodFullName = "strlen", mappings = List(), regex = false),
  FlowSemantic(
    methodFullName = "strcpy",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "strstr",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "memset",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 2, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "system",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 1, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "snprintf",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 3, name = None),
        dst = ParameterNode(index = 1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(
    methodFullName = "popen",
    mappings = List(
      FlowMapping(
        src = ParameterNode(index = 1, name = None),
        dst = ParameterNode(index = -1, name = None)
      )
    ),
    regex = false
  ),
  FlowSemantic(methodFullName = "pclose", mappings = List(), regex = false)
)
=~...
2025-06-09 13:44:25,775 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)...
2025-06-09 13:44:26,036 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val semantics: Semantics = DefaultSemantics().plus(extraFlows)
>val semantics: io.joern.dataflowengineoss.semanticsloader.Semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@292fcda
=~...
2025-06-09 13:44:26,036 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: implicit val context: EngineContext = EngineContext(semantics = semantics)...
2025-06-09 13:44:26,322 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: implicit val context: EngineContext = EngineContext(semantics = semantics
s)
>val context: io.joern.dataflowengineoss.queryengine.EngineContext = EngineContext(
  semantics = io.joern.dataflowengineoss.semanticsloader.FullNameSemantics@292fcda,
  config = EngineConfig(
    maxCallDepth = 4,
    initialTable = None,
    shareCacheBetweenTasks = true,
    maxArgsToAllow = 1000,
    maxOutputArgsExpansion = 1000
  )
)
=~...
2025-06-09 13:44:26,323 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 语义规则应用成功
2025-06-09 13:44:26,323 - CPGvulnHunter.passes.initPass.InitPass - INFO - Generated 11 semantic rules for external functions.
2025-06-09 13:44:26,323 - VulnerabilityEngine - INFO - Pass init 执行成功，耗时: 175.29秒
2025-06-09 13:44:26,323 - VulnerabilityEngine - INFO - ✓ Pass init 执行成功
2025-06-09 13:44:26,323 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-09 13:44:26,323 - VulnerabilityEngine - INFO - 
--- 执行Pass 2/2: cwe78 ---
2025-06-09 13:44:26,324 - VulnerabilityEngine - INFO - 执行Pass: cwe78
2025-06-09 13:44:26,324 - root - INFO - 开始执行 CWE-78 OS Command Injection Analysis Pass Pass
2025-06-09 13:44:26,324 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:44:26,324 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: get_user_input\nFull Name: get_user_input\nSignature: char*()\nFile: command.c\ncode: char* get_user_input() {\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "get_user_input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:44:26,325 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:44:26,327 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-cc0828c5-80b2-40ec-a59f-74bb5f50725c', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: get_user_input\nFull Name: get_user_input\nSignature: char*()\nFile: command.c\ncode: char* get_user_input() {\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "get_user_input",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:44:26,328 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:44:26,329 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:44:26,329 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:44:26,329 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:44:26,330 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:44:26,330 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:44:44,191 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:44:25 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1758'), (b'content-type', b'application/json'), (b'x-process-time', b'18')])
2025-06-09 13:44:44,192 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:44:44,192 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:44:44,193 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:44:44,193 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:44:44,193 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:44:44,193 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:44:25 GMT', 'server': 'uvicorn', 'content-length': '1758', 'content-type': 'application/json', 'x-process-time': '18'})
2025-06-09 13:44:44,194 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:44:44,195 - root - DEBUG - 正在提取JSON，原始文本长度: 622, 清理后长度: 622
2025-06-09 13:44:44,196 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "get_user_input",
        "roles": [
           ...
2025-06-09 13:44:44,196 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:44:44,196 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 17.87秒
2025-06-09 13:44:44,196 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:44:44,196 - root - INFO - 函数 get_user_input 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: 函数从用户获取输入并返回这个输入，没有进行任何清理或验证。
2025-06-09 13:44:44,197 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:44:44,197 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: command.c:<global>\nSignature: N/A\nFile: command.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "command.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:44:44,197 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:44:44,199 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-16b14d93-0fdf-41c0-8a07-56644bc6e0bd', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: command.c:<global>\nSignature: N/A\nFile: command.c\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "command.c:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:44:44,200 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:44:44,201 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:44:44,202 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:44:44,202 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:44:44,202 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:44:44,202 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:44:53,219 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:44:43 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1255'), (b'content-type', b'application/json'), (b'x-process-time', b'9')])
2025-06-09 13:44:53,220 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:44:53,221 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:44:53,221 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:44:53,221 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:44:53,222 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:44:53,222 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:44:43 GMT', 'server': 'uvicorn', 'content-length': '1255', 'content-type': 'application/json', 'x-process-time': '9'})
2025-06-09 13:44:53,222 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:44:53,223 - root - DEBUG - 正在提取JSON，原始文本长度: 279, 清理后长度: 279
2025-06-09 13:44:53,224 - root - DEBUG - 模式 3 找到内容: c
void some_function(char *input) {
    char command[1024];
    strcpy(command, input);
    system(c...
2025-06-09 13:44:53,225 - root - DEBUG - 找到嵌入JSON: [1024]...
2025-06-09 13:44:53,226 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 9.03秒
2025-06-09 13:44:53,226 - CPGvulnHunter.bridges.llmWrapper - ERROR - LLM返回数据不是字典类型: <class 'list'>
2025-06-09 13:44:53,226 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:44:53,226 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: basic_validate\nFull Name: basic_validate\nSignature: char*(char*)\nFile: command.c\ncode: char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "basic_validate",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:44:53,227 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:44:53,229 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-fe8ad9f9-a8e3-4d39-9f5e-0869cef04bb9', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: basic_validate\nFull Name: basic_validate\nSignature: char*(char*)\nFile: command.c\ncode: char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "basic_validate",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:44:53,230 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:44:53,231 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:44:53,231 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:44:53,232 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:44:53,232 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:44:53,232 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:45:15,566 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:44:52 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2325'), (b'content-type', b'application/json'), (b'x-process-time', b'22')])
2025-06-09 13:45:15,567 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:45:15,567 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:45:15,568 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:45:15,568 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:45:15,568 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:45:15,569 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:44:52 GMT', 'server': 'uvicorn', 'content-length': '2325', 'content-type': 'application/json', 'x-process-time': '22'})
2025-06-09 13:45:15,569 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:45:15,570 - root - DEBUG - 正在提取JSON，原始文本长度: 968, 清理后长度: 968
2025-06-09 13:45:15,571 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "basic_validate",
        "roles": [
           ...
2025-06-09 13:45:15,571 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:45:15,571 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 22.34秒
2025-06-09 13:45:15,571 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:45:15,571 - root - INFO - 函数 basic_validate 角色: SOURCE, 参数索引: 1, 置信度: 0.9, 理由: 函数接收用户提供的输入作为参数
2025-06-09 13:45:15,572 - root - INFO - 函数 basic_validate 角色: SANITIZER, 参数索引: -1, 置信度: 0.9, 理由: 函数清理或替换潜在危险的命令字符串，以防止命令注入攻击
2025-06-09 13:45:15,572 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:45:15,572 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: execute_command\nFull Name: execute_command\nSignature: void(char*)\nFile: command.c\ncode: void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "execute_command",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:45:15,572 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:45:15,574 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2795c4fc-6237-4255-bf57-226574a75507', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: execute_command\nFull Name: execute_command\nSignature: void(char*)\nFile: command.c\ncode: void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "execute_command",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:45:15,576 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:45:15,576 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:45:15,577 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:45:15,577 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:45:15,577 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:45:15,578 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:45:42,496 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:45:14 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2733'), (b'content-type', b'application/json'), (b'x-process-time', b'27')])
2025-06-09 13:45:42,496 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:45:42,496 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:45:42,496 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:45:42,497 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:45:42,497 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:45:42,497 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:45:14 GMT', 'server': 'uvicorn', 'content-length': '2733', 'content-type': 'application/json', 'x-process-time': '27'})
2025-06-09 13:45:42,497 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:45:42,498 - root - DEBUG - 正在提取JSON，原始文本长度: 1235, 清理后长度: 1235
2025-06-09 13:45:42,498 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "execute_command",
        "roles": [
          ...
2025-06-09 13:45:42,498 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:45:42,498 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 26.93秒
2025-06-09 13:45:42,498 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:45:42,498 - root - INFO - 函数 execute_command 角色: SOURCE, 参数索引: 1, 置信度: 0.85, 理由: 尽管函数本身不直接获取数据，但如果传入的是不受信任的数据，则可能引入命令注入风险。
2025-06-09 13:45:42,498 - root - INFO - 函数 execute_command 角色: SINK, 参数索引: -1, 置信度: 1.0, 理由: 通过调用 system() 函数来执行输入参数中的命令。
2025-06-09 13:45:42,498 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:45:42,498 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: list_files\nFull Name: list_files\nSignature: void(char*)\nFile: command.c\ncode: void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "list_files",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:45:42,498 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:45:42,499 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-25f28e16-ac02-46aa-abc3-1ed73345e321', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: list_files\nFull Name: list_files\nSignature: void(char*)\nFile: command.c\ncode: void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "list_files",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:45:42,500 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:45:42,500 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:45:42,500 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:45:42,500 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:45:42,501 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:45:42,501 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:46:01,096 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:45:41 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2036'), (b'content-type', b'application/json'), (b'x-process-time', b'19')])
2025-06-09 13:46:01,097 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:46:01,097 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:46:01,098 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:46:01,098 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:46:01,098 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:46:01,098 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:45:41 GMT', 'server': 'uvicorn', 'content-length': '2036', 'content-type': 'application/json', 'x-process-time': '19'})
2025-06-09 13:46:01,099 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:46:01,100 - root - DEBUG - 正在提取JSON，原始文本长度: 807, 清理后长度: 807
2025-06-09 13:46:01,100 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "list_files",
        "roles": [
            {
 ...
2025-06-09 13:46:01,100 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:46:01,101 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 18.60秒
2025-06-09 13:46:01,101 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:46:01,101 - root - INFO - 函数 list_files 角色: SOURCE, 参数索引: 1, 置信度: 0.9, 理由: path 参数用于构造系统命令，但未进行任何验证或清理
2025-06-09 13:46:01,101 - root - INFO - 函数 list_files 角色: SINK, 参数索引: 1, 置信度: 0.9, 理由: 通过 popen 执行由 path 构造的系统命令
2025-06-09 13:46:01,101 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:46:01,101 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: command.c\ncode: int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:46:01,102 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:46:01,104 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-d3122a42-71d0-42ef-b66f-7a0d67615bfa', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: main\nFull Name: main\nSignature: int()\nFile: command.c\ncode: int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "main",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:46:01,105 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:46:01,106 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:46:01,106 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:46:01,107 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:46:01,107 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:46:01,107 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:46:23,849 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:46:00 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2493'), (b'content-type', b'application/json'), (b'x-process-time', b'22')])
2025-06-09 13:46:23,850 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:46:23,850 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:46:23,851 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:46:23,851 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:46:23,851 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:46:23,851 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:46:00 GMT', 'server': 'uvicorn', 'content-length': '2493', 'content-type': 'application/json', 'x-process-time': '22'})
2025-06-09 13:46:23,851 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:46:23,853 - root - DEBUG - 正在提取JSON，原始文本长度: 1160, 清理后长度: 1160
2025-06-09 13:46:23,853 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "main",
        "roles": [
            {
       ...
2025-06-09 13:46:23,853 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:46:23,854 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 22.75秒
2025-06-09 13:46:23,854 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:46:23,854 - root - INFO - 函数 main 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: get_user_input() 函数获取用户输入，是可能引入不受信任数据的函数。
2025-06-09 13:46:23,854 - root - INFO - 函数 main 角色: SANITIZER, 参数索引: -1, 置信度: 1.0, 理由: basic_validate(user_path) 对 user_path 进行基本验证，以清理或验证输入数据防止命令注入。
2025-06-09 13:46:23,854 - root - INFO - 函数 main 角色: SINK, 参数索引: 1, 置信度: 0.8, 理由: list_files(validated_path) 函数有可能调用其他函数执行系统命令（例如通过 shell 命令列出文件），但未直接看到该行为，所以置信度为 0.8。
2025-06-09 13:46:23,855 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:46:23,855 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:46:23,855 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:46:23,857 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-faba6d2b-563c-49ef-ab15-5b50f77e8968', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: <global>\nFull Name: <includes>:<global>\nSignature: N/A\nFile: <includes>\ncode: <global>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "<includes>:<global>",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:46:23,859 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:46:23,859 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:46:23,860 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:46:23,860 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:46:23,860 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:46:23,860 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:46:41,545 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:46:22 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2119'), (b'content-type', b'application/json'), (b'x-process-time', b'18')])
2025-06-09 13:46:41,546 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:46:41,547 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:46:41,547 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:46:41,547 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:46:41,547 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:46:41,548 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:46:22 GMT', 'server': 'uvicorn', 'content-length': '2119', 'content-type': 'application/json', 'x-process-time': '18'})
2025-06-09 13:46:41,548 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:46:41,549 - root - DEBUG - 正在提取JSON，原始文本长度: 732, 清理后长度: 732
2025-06-09 13:46:41,550 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "<includes>:<global>",
        "roles": [
      ...
2025-06-09 13:46:41,550 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:46:41,550 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 17.70秒
2025-06-09 13:46:41,550 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:46:41,550 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:46:41,551 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: MAX_BUFFER\nFull Name: command.c:6:6:MAX_BUFFER:0\nSignature: N/A\nFile: command.c\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "command.c:6:6:MAX_BUFFER:0",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:46:41,551 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:46:41,553 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-579c3553-0647-42f9-80ef-b72dc87095e5', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: MAX_BUFFER\nFull Name: command.c:6:6:MAX_BUFFER:0\nSignature: N/A\nFile: command.c\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "command.c:6:6:MAX_BUFFER:0",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:46:41,554 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:46:41,564 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:46:41,567 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:46:41,567 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:46:41,567 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:46:41,567 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:46:59,287 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:46:40 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2026'), (b'content-type', b'application/json'), (b'x-process-time', b'18')])
2025-06-09 13:46:59,289 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:46:59,290 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:46:59,291 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:46:59,291 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:46:59,291 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:46:59,291 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:46:40 GMT', 'server': 'uvicorn', 'content-length': '2026', 'content-type': 'application/json', 'x-process-time': '18'})
2025-06-09 13:46:59,292 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:46:59,298 - root - DEBUG - 正在提取JSON，原始文本长度: 733, 清理后长度: 733
2025-06-09 13:46:59,299 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "command.c:6:6:MAX_BUFFER:0",
        "roles": [...
2025-06-09 13:46:59,299 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:46:59,299 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 17.75秒
2025-06-09 13:46:59,299 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:46:59,300 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:46:59,300 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:46:59,301 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:46:59,305 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-f1e8562c-0f4e-4612-bba0-879e2620ab91', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: printf\nFull Name: printf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "printf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:46:59,308 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:46:59,309 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:46:59,309 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:46:59,310 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:46:59,310 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:46:59,310 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:10,737 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:46:58 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1464'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:47:10,738 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:10,739 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:10,739 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:10,739 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:10,739 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:10,740 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:46:58 GMT', 'server': 'uvicorn', 'content-length': '1464', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:47:10,740 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:10,741 - root - DEBUG - 正在提取JSON，原始文本长度: 473, 清理后长度: 473
2025-06-09 13:47:10,741 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "printf",
        "roles": [
            {
     ...
2025-06-09 13:47:10,742 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:47:10,742 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 11.44秒
2025-06-09 13:47:10,742 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:47:10,742 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:10,742 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:10,743 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:10,745 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-2bf5ba68-c011-4555-aa8e-907b24709de9', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: fgets\nFull Name: fgets\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "fgets",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:10,747 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:10,748 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:10,749 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:10,749 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:10,749 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:10,750 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:17,969 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:10 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1082'), (b'content-type', b'application/json'), (b'x-process-time', b'7')])
2025-06-09 13:47:17,970 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:17,971 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:17,971 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:17,971 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:17,972 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:17,972 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:10 GMT', 'server': 'uvicorn', 'content-length': '1082', 'content-type': 'application/json', 'x-process-time': '7'})
2025-06-09 13:47:17,972 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:17,973 - root - DEBUG - 正在提取JSON，原始文本长度: 320, 清理后长度: 320
2025-06-09 13:47:17,974 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "fgets",
        "roles": [
            {
      ...
2025-06-09 13:47:17,974 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:47:17,974 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 7.23秒
2025-06-09 13:47:17,974 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:47:17,975 - root - INFO - 函数 fgets 角色: SOURCE, 参数索引: -1, 置信度: 1.0, 理由: fgets 函数从标准输入、文件或管道读取用户提供的数据，这直接引入了不受信任的数据源。
2025-06-09 13:47:17,975 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:17,975 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strlen\nFull Name: strlen\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strlen",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:17,976 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:17,978 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-7f0d3d05-75ec-4ee7-8d53-e6bdeb782560', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strlen\nFull Name: strlen\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strlen",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:17,979 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:17,980 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:17,980 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:17,980 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:17,981 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:17,981 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:25,136 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:17 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1079'), (b'content-type', b'application/json'), (b'x-process-time', b'8')])
2025-06-09 13:47:25,137 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:25,137 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:25,138 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:25,138 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:25,138 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:25,138 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:17 GMT', 'server': 'uvicorn', 'content-length': '1079', 'content-type': 'application/json', 'x-process-time': '8'})
2025-06-09 13:47:25,138 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:25,140 - root - DEBUG - 正在提取JSON，原始文本长度: 318, 清理后长度: 318
2025-06-09 13:47:25,140 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strlen",
        "roles": [
            {
     ...
2025-06-09 13:47:25,140 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:47:25,140 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 7.17秒
2025-06-09 13:47:25,141 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:47:25,141 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:25,141 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strcpy\nFull Name: strcpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strcpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:25,141 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:25,143 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-bc358265-846f-44f2-82d5-a282e9a599db', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strcpy\nFull Name: strcpy\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strcpy",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:25,145 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:25,145 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:25,146 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:25,146 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:25,146 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:25,146 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:36,238 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:25 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1424'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:47:36,238 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:36,239 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:36,239 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:36,239 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:36,240 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:36,240 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:25 GMT', 'server': 'uvicorn', 'content-length': '1424', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:47:36,240 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:36,241 - root - DEBUG - 正在提取JSON，原始文本长度: 455, 清理后长度: 455
2025-06-09 13:47:36,242 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strcpy",
        "roles": [
            {
     ...
2025-06-09 13:47:36,242 - root - DEBUG - 模式 1 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 317)
2025-06-09 13:47:36,242 - root - DEBUG - 模式 2 找到内容: {
    "analysis_result": {
        "function_name": "strcpy",
        "roles": [
            {
     ...
2025-06-09 13:47:36,243 - root - DEBUG - 模式 2 JSON无效: Expecting property name enclosed in double quotes: line 10 column 13 (char 317)
2025-06-09 13:47:36,243 - root - DEBUG - 模式 3 找到内容: json
{
    "analysis_result": {
        "function_name": "strcpy",
        "roles": [
            {
...
2025-06-09 13:47:36,245 - root - ERROR - 无法提取JSON，原始文本: ```json
{
    "analysis_result": {
        "function_name": "strcpy",
        "roles": [
            {
                "role": "NONE",
                "parameter_index": "-1",
                "confidence": 1.0,
                "reason": "strcpy函数用于在内存中复制字符串，它不会直接执行系统命令、从不受信任的来源获取输入或清理数据。因此，它与CWE-78（OS命令注入）无关。",
            }
        ]
    }
}
```

### 分析说明
`strcpy` 函数主要用于将一个源字符串复制到目标缓冲区中。该函数本身不会直接执行系统命令、从不受信任的来源获取输入或清理数据，因此它在CWE-78（OS命令注入）漏洞中的角色为NONE。
2025-06-09 13:47:36,245 - CPGvulnHunter.bridges.llmWrapper - ERROR - 分析函数时发生错误: 在文本中未找到有效的JSON内容。文本长度: 455
2025-06-09 13:47:36,245 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误类型: ValueError
2025-06-09 13:47:36,251 - CPGvulnHunter.bridges.llmWrapper - ERROR - 错误堆栈: Traceback (most recent call last):
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmWrapper.py", line 224, in analyze_function
    data: dict = self.llm_client.send(llmRequest, True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/bridges/llmBridge.py", line 38, in send
    jsonContent = extract_json_block(response_text)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/nstl/data/CPGvulnHunter/src/CPGvulnHunter/utils/uitils.py", line 1940, in extract_json_block
    raise ValueError(f"在文本中未找到有效的JSON内容。文本长度: {len(text)}")
ValueError: 在文本中未找到有效的JSON内容。文本长度: 455

2025-06-09 13:47:36,252 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:36,252 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strstr\nFull Name: strstr\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strstr",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:36,252 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:36,254 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-070db8b3-99b3-4fd4-9318-6d99e515bc98', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: strstr\nFull Name: strstr\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "strstr",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:36,256 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:36,256 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:36,257 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:36,257 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:36,257 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:36,258 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:47,880 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:36 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1498'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:47:47,881 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:47,881 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:47,881 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:47,882 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:47,882 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:47,882 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:36 GMT', 'server': 'uvicorn', 'content-length': '1498', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:47:47,882 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:47,883 - root - DEBUG - 正在提取JSON，原始文本长度: 497, 清理后长度: 497
2025-06-09 13:47:47,884 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "strstr",
        "roles": [
            {
     ...
2025-06-09 13:47:47,884 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:47:47,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 11.63秒
2025-06-09 13:47:47,884 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:47:47,885 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:47,885 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: memset\nFull Name: memset\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "memset",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:47,885 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:47,887 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-0c5399ae-bee3-42d2-9bcf-87a4a76c2427', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: memset\nFull Name: memset\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "memset",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:47,888 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:47,889 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:47,890 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:47,890 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:47,890 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:47,890 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:47:55,802 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:47 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1159'), (b'content-type', b'application/json'), (b'x-process-time', b'8')])
2025-06-09 13:47:55,803 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:47:55,803 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:47:55,804 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:47:55,804 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:47:55,804 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:47:55,804 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:47 GMT', 'server': 'uvicorn', 'content-length': '1159', 'content-type': 'application/json', 'x-process-time': '8'})
2025-06-09 13:47:55,805 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:47:55,806 - root - DEBUG - 正在提取JSON，原始文本长度: 344, 清理后长度: 344
2025-06-09 13:47:55,806 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "memset",
        "roles": [
            {
     ...
2025-06-09 13:47:55,806 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:47:55,807 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 7.92秒
2025-06-09 13:47:55,807 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:47:55,807 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:47:55,807 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: system\nFull Name: system\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "system",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:47:55,807 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:47:55,810 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-3747c436-ed9e-43f0-96fe-163640d4031a', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: system\nFull Name: system\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "system",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:47:55,811 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:47:55,812 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:47:55,812 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:47:55,812 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:47:55,813 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:47:55,813 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:48:15,003 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:47:55 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2095'), (b'content-type', b'application/json'), (b'x-process-time', b'19')])
2025-06-09 13:48:15,004 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:48:15,005 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:48:15,005 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:48:15,005 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:48:15,005 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:48:15,006 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:47:55 GMT', 'server': 'uvicorn', 'content-length': '2095', 'content-type': 'application/json', 'x-process-time': '19'})
2025-06-09 13:48:15,006 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:48:15,007 - root - DEBUG - 正在提取JSON，原始文本长度: 775, 清理后长度: 775
2025-06-09 13:48:15,007 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "system",
        "roles": [
            {
     ...
2025-06-09 13:48:15,008 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:48:15,008 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 19.20秒
2025-06-09 13:48:15,008 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:48:15,008 - root - INFO - 函数 system 角色: SINK, 参数索引: 1, 置信度: 1.0, 理由: 函数直接执行shell命令，非常危险。
2025-06-09 13:48:15,008 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:48:15,009 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: snprintf\nFull Name: snprintf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "snprintf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:48:15,009 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:48:15,011 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-41f2fb82-baed-43ac-b07e-e73afbe31d82', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: snprintf\nFull Name: snprintf\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "snprintf",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:48:15,012 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:48:15,013 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:48:15,013 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:48:15,013 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:48:15,014 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:48:15,014 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:48:28,935 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:48:14 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1725'), (b'content-type', b'application/json'), (b'x-process-time', b'13')])
2025-06-09 13:48:28,936 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:48:28,936 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:48:28,937 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:48:28,937 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:48:28,937 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:48:28,937 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:48:14 GMT', 'server': 'uvicorn', 'content-length': '1725', 'content-type': 'application/json', 'x-process-time': '13'})
2025-06-09 13:48:28,937 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:48:28,939 - root - DEBUG - 正在提取JSON，原始文本长度: 580, 清理后长度: 580
2025-06-09 13:48:28,939 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "snprintf",
        "roles": [
            {
   ...
2025-06-09 13:48:28,939 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:48:28,939 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 13.93秒
2025-06-09 13:48:28,939 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:48:28,940 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:48:28,940 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: popen\nFull Name: popen\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "popen",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:48:28,940 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:48:28,942 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-61b73131-cb6f-470f-b756-932dd2f84751', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: popen\nFull Name: popen\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "popen",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:48:28,943 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:48:28,944 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:48:28,945 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:48:28,945 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:48:28,945 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:48:28,945 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:48:57,717 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:48:28 GMT'), (b'server', b'uvicorn'), (b'content-length', b'2908'), (b'content-type', b'application/json'), (b'x-process-time', b'29')])
2025-06-09 13:48:57,718 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:48:57,718 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:48:57,718 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:48:57,719 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:48:57,719 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:48:57,719 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:48:28 GMT', 'server': 'uvicorn', 'content-length': '2908', 'content-type': 'application/json', 'x-process-time': '29'})
2025-06-09 13:48:57,719 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:48:57,721 - root - DEBUG - 正在提取JSON，原始文本长度: 1248, 清理后长度: 1248
2025-06-09 13:48:57,721 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "popen",
        "roles": [
            {
      ...
2025-06-09 13:48:57,721 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:48:57,721 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 28.78秒
2025-06-09 13:48:57,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:48:57,722 - root - INFO - 函数 popen 角色: SOURCE, 参数索引: 1, 置信度: 0.9, 理由: 参数command可能来自不受信任的数据源，存在注入风险。
2025-06-09 13:48:57,722 - root - INFO - 函数 popen 角色: SINK, 参数索引: 1, 置信度: 0.95, 理由: 函数执行传递给它的shell命令，可能导致命令注入攻击。
2025-06-09 13:48:57,722 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析LLM请求
2025-06-09 13:48:57,722 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: pclose\nFull Name: pclose\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "pclose",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}]
2025-06-09 13:48:57,723 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:48:57,725 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-dd34994f-bcff-41e2-ab77-87a151498e4e', 'json_data': {'messages': [{'role': 'system', 'content': '你是一个专业的代码安全分析专家，专注于识别CWE-78（OS命令注入）漏洞。\n    请分析给定的函数，判断其在命令注入攻击链中的角色。\n\n    角色定义：\n    1. SOURCE: 可能引入不受信任数据的函数\n    - 用户输入函数（如scanf, fgets, getchar等）\n    - 命令行参数（如argv）\n    - 环境变量获取（如getenv）\n    - 网络数据接收（如recv, read等）\n    - 文件读取函数\n\n    2. SINK: 可能执行OS命令的危险函数\n    - 直接命令执行（如system, exec系列函数）\n    - 管道操作（如popen）\n    - 脚本解释器调用\n\n    3. SANITIZER: 可以清理/验证数据以防止命令注入的函数\n    - 输入验证函数\n    - 命令转义函数（如escapeshellarg）\n    - 白名单过滤函数\n    - 参数清理函数\n\n    4. NONE: 与命令注入无关的函数'}, {'role': 'user', 'content': '请分析以下函数：\n\n    Function Name: pclose\nFull Name: pclose\nSignature: N/A\nFile: <empty>\ncode: <empty>\n\n\n    请返回一个JSON对象，包含以下字段：\n    {\n        "analysis_result": {\n            "function_name": "pclose",\n            "roles": [\n                {\n                    "role": "SOURCE|SINK|SANITIZER|NONE",\n                    "parameter_index": "参数索引（-1表示返回值，1表示第一个参数等）",\n                    "confidence": "置信度（0.0-1.0）",\n                    "reason": "判断理由",\n                }\n            ]\n        }\n    }\n\n    分析要求：\n    1. 一个函数可能具有多个角色\n    2. 只返回置信度 >= 0.6 的结果\n    3. 重点关注函数的实际行为，不仅仅是函数名\n    4. 考虑函数参数的用途和返回值的性质\n\n    示例分析思路：\n    - 如果函数从用户获取输入 → 可能是SOURCE\n    - 如果函数执行系统命令 → 可能是SINK  \n    - 如果函数验证或清理输入 → 可能是SANITIZER\n    - 如果函数与命令执行无关 → 标记为NONE'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:48:57,726 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:48:57,727 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:48:57,727 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:48:57,728 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:48:57,728 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:48:57,728 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:49:08,130 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:48:57 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1355'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:49:08,130 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:49:08,130 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:49:08,130 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:49:08,130 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:49:08,131 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:49:08,131 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:48:57 GMT', 'server': 'uvicorn', 'content-length': '1355', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:49:08,131 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:49:08,131 - root - DEBUG - 正在提取JSON，原始文本长度: 439, 清理后长度: 439
2025-06-09 13:49:08,131 - root - DEBUG - 模式 1 找到内容: {
    "analysis_result": {
        "function_name": "pclose",
        "roles": [
            {
     ...
2025-06-09 13:49:08,131 - root - DEBUG - 模式 1 解析成功
2025-06-09 13:49:08,132 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM请求完成，耗时: 10.41秒
2025-06-09 13:49:08,132 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM响应数据包含 1 个顶级字段: ['analysis_result']
2025-06-09 13:49:08,132 - CWE78 - INFO - 分析完成，找到 7 个源函数，5 个汇聚点函数，2 个清理函数
2025-06-09 13:49:08,132 - root - INFO - 找到 7 个源函数，5 个汇聚点函数，2 个清理函数
2025-06-09 13:49:08,132 - root - INFO - 源函数列表: ['get_user_input', 'basic_validate', 'execute_command', 'list_files', 'main', 'fgets', 'popen']
2025-06-09 13:49:08,132 - root - INFO - 汇聚点函数列表: ['execute_command', 'list_files', 'main', 'system', 'popen']
2025-06-09 13:49:08,132 - root - INFO - 清理函数列表: ['basic_validate', 'main']
2025-06-09 13:49:08,132 - root - ERROR - 分析源 get_user_input 到汇聚点 execute_command 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:08,132 - root - ERROR - 分析源 get_user_input 到汇聚点 list_files 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:08,132 - root - ERROR - 分析源 get_user_input 到汇聚点 main 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:08,132 - root - ERROR - 分析源 get_user_input 到汇聚点 system 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:08,132 - root - ERROR - 分析源 get_user_input 到汇聚点 popen 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:08,132 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:08,617 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(c
cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty
>val res55: String = """[
  
]"""
=~...
2025-06-09 13:49:08,618 - root - INFO - 分析源 basic_validate 到汇聚点 execute_command 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='basic_validate', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}', column_number=1, column_number_end=26, filename='command.c', full_name='basic_validate', generic_signature='<empty>', hash_value=None, is_external=False, line_number=27, line_number_end=42, offset=None, offset_end=None, order=1, signature='char*(char*)', parameters=None, useage=None, index=1), sink=Sink(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=-1))
2025-06-09 13:49:08,618 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:09,035 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(
(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty
>val res56: String = """[
  {
    "path":[
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"input",
          "_id":115964116992,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"char*",
          "lineNumber":27,
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"char* input",
          "columnNumber":22
        },
        "callSiteStack":[
          {
            "name":"basic_validate",
            "_id":30064771126,
            "signature":"",
            "code":"basic_validate(user_path)",
            "typeFullName":"char*",
            "lineNumber":68,
            "order":2,
            "methodFullName":"basic_validate",
            "_label":"CALL",
            "dynamicTypeHintFullName":[
              
            ],
            "dispatchType":"STATIC_DISPATCH",
            "columnNumber":28,
            "possibleTypes":[
              
            ],
            "argumentIndex":2
          }
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"input"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"input",
          "_id":68719476750,
          "code":"input",
          "typeFullName":"char*",
          "lineNumber":29,
          "order":2,
          "_label":"IDENTIFIER",
          "columnNumber":23,
          "possibleTypes":[
            
          ],
          "argumentIndex":2
        },
        "callSiteStack":[
          {
            "name":"basic_validate",
            "_id":30064771126,
            "signature":"",
            "code":"basic_validate(user_path)",
            "typeFullName":"char*",
            "lineNumber":68,
            "order":2,
            "methodFullName":"basic_validate",
            "_label":"CALL",
            "dynamicTypeHintFullName":[
              
            ],
            "dispatchType":"STATIC_DISPATCH",
            "columnNumber":28,
            "possibleTypes":[
              
            ],
            "argumentIndex":2
          }
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"input"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"validated",
          "_id":68719476749,
          "code":"validated",
          "typeFullName":"char[256]",
          "lineNumber":29,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":12,
          "possibleTypes":[
            
          ],
          "argumentIndex":1
        },
        "callSiteStack":[
          {
            "name":"basic_validate",
            "_id":30064771126,
            "signature":"",
            "code":"basic_validate(user_path)",
            "typeFullName":"char*",
            "lineNumber":68,
            "order":2,
            "methodFullName":"basic_validate",
            "_label":"CALL",
            "dynamicTypeHintFullName":[
              
            ],
            "dispatchType":"STATIC_DISPATCH",
            "columnNumber":28,
            "possibleTypes":[
              
            ],
            "argumentIndex":2
          }
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"validated"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"validated",
          "_id":68719476767,
          "code":"validated",
          "typeFullName":"char[256]",
          "lineNumber":41,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":12,
          "possibleTypes":[
            
          ],
          "argumentIndex":-1
        },
        "callSiteStack":[
          {
            "name":"basic_validate",
            "_id":30064771126,
            "signature":"",
            "code":"basic_validate(user_path)",
            "typeFullName":"char*",
            "lineNumber":68,
            "order":2,
            "methodFullName":"basic_validate",
            "_label":"CALL",
            "dynamicTypeHintFullName":[
              
            ],
            "dispatchType":"STATIC_DISPATCH",
            "columnNumber":28,
            "possibleTypes":[
              
            ],
            "argumentIndex":2
          }
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"validated"
      },
      {
        "node":{
          "_id":146028888065,
          "code":"return validated;",
          "lineNumber":41,
          "order":9,
          "_label":"RETURN",
          "argumentIndex":-1,
          "columnNumber":5
        },
        "callSiteStack":[
          {
            "name":"basic_validate",
            "_id":30064771126,
            "signature":"",
            "code":"basic_validate(user_path)",
            "typeFullName":"char*",
            "lineNumber":68,
            "order":2,
            "methodFullName":"basic_validate",
            "_label":"CALL",
            "dynamicTypeHintFullName":[
              
            ],
            "dispatchType":"STATIC_DISPATCH",
            "columnNumber":28,
            "possibleTypes":[
              
            ],
            "argumentIndex":2
          }
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "_id":128849018881,
          "evaluationStrategy":"BY_VALUE",
          "code":"RET",
          "typeFullName":"char*",
          "lineNumber":27,
          "order":3,
          "_label":"METHOD_RETURN",
          "possibleTypes":[
            
          ],
          "columnNumber":1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      },
      {
        "node":{
          "name":"basic_validate",
          "_id":30064771126,
          "signature":"",
          "code":"basic_validate(user_path)",
          "typeFullName":"char*",
          "lineNumber":68,
          "order":2,
          "methodFullName":"basic_validate",
          "_label":"CALL",
          "dynamicTypeHintFullName":[
            
          ],
          "dispatchType":"STATIC_DISPATCH",
          "columnNumber":28,
          "possibleTypes":[
            
          ],
          "argumentIndex":2
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":true,
        "outEdgeLabel":""
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"validated_path",
          "_id":68719476784,
          "code":"validated_path",
          "typeFullName":"char*",
          "lineNumber":68,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":11,
          "possibleTypes":[
            
          ],
          "argumentIndex":1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"validated_path"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"validated_path",
          "_id":68719476786,
          "code":"validated_path",
          "typeFullName":"char*",
          "lineNumber":69,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":16,
          "possibleTypes":[
            
          ],
          "argumentIndex":1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"path",
          "_id":115964116994,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"char*",
          "lineNumber":51,
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"char* path",
          "columnNumber":17
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      }
    ]
  }
]"""
=~...
2025-06-09 13:49:09,036 - root - DEBUG - 添加数据流路径: Data flow: input (line 27) -> path (line 51)
2025-06-09 13:49:09,036 - root - INFO - 分析源 basic_validate 到汇聚点 list_files 的数据流结果: DataFlowResult(flows=[FlowPath(nodes=[FlowNode(node_id=115964116992, label='METHOD_PARAMETER_IN', code='char* input', line_number=27, column_number=22, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='input', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[{'name': 'basic_validate', '_id': 30064771126, 'signature': '', 'code': 'basic_validate(user_path)', 'typeFullName': 'char*', 'lineNumber': 68, 'order': 2, 'methodFullName': 'basic_validate', '_label': 'CALL', 'dynamicTypeHintFullName': [], 'dispatchType': 'STATIC_DISPATCH', 'columnNumber': 28, 'possibleTypes': [], 'argumentIndex': 2}], visible=True, is_output_arg=False, out_edge_label='input', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476750, label='IDENTIFIER', code='input', line_number=29, column_number=23, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='input', order=2, index=None, evaluation_strategy=None, is_variadic=None, argument_index=2, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[{'name': 'basic_validate', '_id': 30064771126, 'signature': '', 'code': 'basic_validate(user_path)', 'typeFullName': 'char*', 'lineNumber': 68, 'order': 2, 'methodFullName': 'basic_validate', '_label': 'CALL', 'dynamicTypeHintFullName': [], 'dispatchType': 'STATIC_DISPATCH', 'columnNumber': 28, 'possibleTypes': [], 'argumentIndex': 2}], visible=True, is_output_arg=False, out_edge_label='input', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476749, label='IDENTIFIER', code='validated', line_number=29, column_number=12, type_full_name='char[256]', possible_types=[], dynamic_type_hint_full_name=[], name='validated', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[{'name': 'basic_validate', '_id': 30064771126, 'signature': '', 'code': 'basic_validate(user_path)', 'typeFullName': 'char*', 'lineNumber': 68, 'order': 2, 'methodFullName': 'basic_validate', '_label': 'CALL', 'dynamicTypeHintFullName': [], 'dispatchType': 'STATIC_DISPATCH', 'columnNumber': 28, 'possibleTypes': [], 'argumentIndex': 2}], visible=True, is_output_arg=False, out_edge_label='validated', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476767, label='IDENTIFIER', code='validated', line_number=41, column_number=12, type_full_name='char[256]', possible_types=[], dynamic_type_hint_full_name=[], name='validated', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=-1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[{'name': 'basic_validate', '_id': 30064771126, 'signature': '', 'code': 'basic_validate(user_path)', 'typeFullName': 'char*', 'lineNumber': 68, 'order': 2, 'methodFullName': 'basic_validate', '_label': 'CALL', 'dynamicTypeHintFullName': [], 'dispatchType': 'STATIC_DISPATCH', 'columnNumber': 28, 'possibleTypes': [], 'argumentIndex': 2}], visible=True, is_output_arg=False, out_edge_label='validated', properties={}, methodContext=None, classContext=None), FlowNode(node_id=146028888065, label='RETURN', code='return validated;', line_number=41, column_number=5, type_full_name=None, possible_types=[], dynamic_type_hint_full_name=[], name=None, order=9, index=None, evaluation_strategy=None, is_variadic=None, argument_index=-1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[{'name': 'basic_validate', '_id': 30064771126, 'signature': '', 'code': 'basic_validate(user_path)', 'typeFullName': 'char*', 'lineNumber': 68, 'order': 2, 'methodFullName': 'basic_validate', '_label': 'CALL', 'dynamicTypeHintFullName': [], 'dispatchType': 'STATIC_DISPATCH', 'columnNumber': 28, 'possibleTypes': [], 'argumentIndex': 2}], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None), FlowNode(node_id=128849018881, label='METHOD_RETURN', code='RET', line_number=27, column_number=1, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name=None, order=3, index=None, evaluation_strategy='BY_VALUE', is_variadic=None, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None), FlowNode(node_id=30064771126, label='CALL', code='basic_validate(user_path)', line_number=68, column_number=28, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='basic_validate', order=2, index=None, evaluation_strategy=None, is_variadic=None, argument_index=2, signature='', method_full_name='basic_validate', dispatch_type='STATIC_DISPATCH', call_site_stack=[], visible=True, is_output_arg=True, out_edge_label='', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476784, label='IDENTIFIER', code='validated_path', line_number=68, column_number=11, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='validated_path', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='validated_path', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476786, label='IDENTIFIER', code='validated_path', line_number=69, column_number=16, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='validated_path', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None), FlowNode(node_id=115964116994, label='METHOD_PARAMETER_IN', code='char* path', line_number=51, column_number=17, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='path', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None)], is_vulnerable=False, confidence=0.0, vulnerability_type=None, description=None)], analysis_time=0.0, source=Source(name='basic_validate', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}', column_number=1, column_number_end=26, filename='command.c', full_name='basic_validate', generic_signature='<empty>', hash_value=None, is_external=False, line_number=27, line_number_end=42, offset=None, offset_end=None, order=1, signature='char*(char*)', parameters=None, useage=None, index=1), sink=Sink(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1))
2025-06-09 13:49:09,036 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:09,365 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("basic_validate").parameter.index(1)).toJsonPretty
>val res57: String = """[
  
]"""
=~...
2025-06-09 13:49:09,365 - root - INFO - 分析源 basic_validate 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='basic_validate', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}', column_number=1, column_number_end=26, filename='command.c', full_name='basic_validate', generic_signature='<empty>', hash_value=None, is_external=False, line_number=27, line_number_end=42, offset=None, offset_end=None, order=1, signature='char*(char*)', parameters=None, useage=None, index=1), sink=Sink(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:49:09,365 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:09,705 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.
.method.fullName("basic_validate").parameter.index(1)).toJsonPretty
>val res58: String = """[
  
]"""
=~...
2025-06-09 13:49:09,706 - root - INFO - 分析源 basic_validate 到汇聚点 system 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='basic_validate', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}', column_number=1, column_number_end=26, filename='command.c', full_name='basic_validate', generic_signature='<empty>', hash_value=None, is_external=False, line_number=27, line_number_end=42, offset=None, offset_end=None, order=1, signature='char*(char*)', parameters=None, useage=None, index=1), sink=Sink(name='system', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='system', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:09,706 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.method.fullName("basic_validate").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:09,984 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.m
method.fullName("basic_validate").parameter.index(1)).toJsonPretty
>val res59: String = """[
  
]"""
=~...
2025-06-09 13:49:09,984 - root - INFO - 分析源 basic_validate 到汇聚点 popen 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='basic_validate', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}', column_number=1, column_number_end=26, filename='command.c', full_name='basic_validate', generic_signature='<empty>', hash_value=None, is_external=False, line_number=27, line_number_end=42, offset=None, offset_end=None, order=1, signature='char*(char*)', parameters=None, useage=None, index=1), sink=Sink(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:09,984 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:10,348 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(c
cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty
>val res60: String = """[
  {
    "path":[
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":115964116993,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"char*",
          "lineNumber":45,
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"char* command",
          "columnNumber":22
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"command"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":68719476768,
          "code":"command",
          "typeFullName":"char*",
          "lineNumber":46,
          "order":2,
          "_label":"IDENTIFIER",
          "columnNumber":26,
          "possibleTypes":[
            
          ],
          "argumentIndex":2
        },
        "callSiteStack":[
          
        ],
        "visible":false,
        "isOutputArg":false,
        "outEdgeLabel":"command"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":68719476769,
          "code":"command",
          "typeFullName":"char*",
          "lineNumber":47,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":12,
          "possibleTypes":[
            
          ],
          "argumentIndex":1
        },
        "callSiteStack":[
          
        ],
        "visible":false,
        "isOutputArg":false,
        "outEdgeLabel":"command"
      },
      {
        "node":{
          "name":"system",
          "_id":30064771109,
          "signature":"",
          "code":"system(command)",
          "typeFullName":"ANY",
          "lineNumber":47,
          "order":2,
          "methodFullName":"system",
          "_label":"CALL",
          "dynamicTypeHintFullName":[
            
          ],
          "dispatchType":"STATIC_DISPATCH",
          "columnNumber":5,
          "possibleTypes":[
            
          ],
          "argumentIndex":-1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"system(command)"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "_id":128849018882,
          "evaluationStrategy":"BY_VALUE",
          "code":"RET",
          "typeFullName":"void",
          "lineNumber":45,
          "order":3,
          "_label":"METHOD_RETURN",
          "possibleTypes":[
            
          ],
          "columnNumber":1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      }
    ]
  }
]"""
=~...
2025-06-09 13:49:10,350 - root - DEBUG - 添加数据流路径: Data flow: command (line 45) -> RET (line 45)
2025-06-09 13:49:10,350 - root - INFO - 分析源 execute_command 到汇聚点 execute_command 的数据流结果: DataFlowResult(flows=[FlowPath(nodes=[FlowNode(node_id=115964116993, label='METHOD_PARAMETER_IN', code='char* command', line_number=45, column_number=22, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='command', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476768, label='IDENTIFIER', code='command', line_number=46, column_number=26, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=2, index=None, evaluation_strategy=None, is_variadic=None, argument_index=2, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=False, is_output_arg=False, out_edge_label='command', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476769, label='IDENTIFIER', code='command', line_number=47, column_number=12, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=False, is_output_arg=False, out_edge_label='command', properties={}, methodContext=None, classContext=None), FlowNode(node_id=30064771109, label='CALL', code='system(command)', line_number=47, column_number=5, type_full_name='ANY', possible_types=[], dynamic_type_hint_full_name=[], name='system', order=2, index=None, evaluation_strategy=None, is_variadic=None, argument_index=-1, signature='', method_full_name='system', dispatch_type='STATIC_DISPATCH', call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='system(command)', properties={}, methodContext=None, classContext=None), FlowNode(node_id=128849018882, label='METHOD_RETURN', code='RET', line_number=45, column_number=1, type_full_name='void', possible_types=[], dynamic_type_hint_full_name=[], name=None, order=3, index=None, evaluation_strategy='BY_VALUE', is_variadic=None, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None)], is_vulnerable=False, confidence=0.0, vulnerability_type=None, description=None)], analysis_time=0.0, source=Source(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=-1))
2025-06-09 13:49:10,350 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:10,667 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(
(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty
>val res61: String = """[
  
]"""
=~...
2025-06-09 13:49:10,668 - root - INFO - 分析源 execute_command 到汇聚点 list_files 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1))
2025-06-09 13:49:10,668 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:10,966 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("execute_command").parameter.index(1)).toJsonPretty
>val res62: String = """[
  
]"""
=~...
2025-06-09 13:49:10,966 - root - INFO - 分析源 execute_command 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:49:10,966 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:11,300 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.
.method.fullName("execute_command").parameter.index(1)).toJsonPretty
>val res63: String = """[
  {
    "path":[
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":115964116993,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"char*",
          "lineNumber":45,
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"char* command",
          "columnNumber":22
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":"command"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":68719476768,
          "code":"command",
          "typeFullName":"char*",
          "lineNumber":46,
          "order":2,
          "_label":"IDENTIFIER",
          "columnNumber":26,
          "possibleTypes":[
            
          ],
          "argumentIndex":2
        },
        "callSiteStack":[
          
        ],
        "visible":false,
        "isOutputArg":false,
        "outEdgeLabel":"command"
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"command",
          "_id":68719476769,
          "code":"command",
          "typeFullName":"char*",
          "lineNumber":47,
          "order":1,
          "_label":"IDENTIFIER",
          "columnNumber":12,
          "possibleTypes":[
            
          ],
          "argumentIndex":1
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      },
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"p1",
          "_id":115964117030,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"ANY",
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"p1"
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      }
    ]
  }
]"""
=~...
2025-06-09 13:49:11,301 - root - DEBUG - 添加数据流路径: Data flow: command (line 45) -> p1 (line None)
2025-06-09 13:49:11,301 - root - INFO - 分析源 execute_command 到汇聚点 system 的数据流结果: DataFlowResult(flows=[FlowPath(nodes=[FlowNode(node_id=115964116993, label='METHOD_PARAMETER_IN', code='char* command', line_number=45, column_number=22, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='command', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476768, label='IDENTIFIER', code='command', line_number=46, column_number=26, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=2, index=None, evaluation_strategy=None, is_variadic=None, argument_index=2, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=False, is_output_arg=False, out_edge_label='command', properties={}, methodContext=None, classContext=None), FlowNode(node_id=68719476769, label='IDENTIFIER', code='command', line_number=47, column_number=12, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='command', order=1, index=None, evaluation_strategy=None, is_variadic=None, argument_index=1, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None), FlowNode(node_id=115964117030, label='METHOD_PARAMETER_IN', code='p1', line_number=None, column_number=None, type_full_name='ANY', possible_types=[], dynamic_type_hint_full_name=[], name='p1', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None)], is_vulnerable=False, confidence=0.0, vulnerability_type=None, description=None)], analysis_time=0.0, source=Source(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='system', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='system', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:11,301 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.method.fullName("execute_command").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:11,578 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.m
method.fullName("execute_command").parameter.index(1)).toJsonPretty
>val res64: String = """[
  
]"""
=~...
2025-06-09 13:49:11,579 - root - INFO - 分析源 execute_command 到汇聚点 popen 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:11,579 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:11,892 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(c
cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty
>val res65: String = """[
  
]"""
=~...
2025-06-09 13:49:11,892 - root - INFO - 分析源 list_files 到汇聚点 execute_command 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=-1))
2025-06-09 13:49:11,892 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:12,218 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(
(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty
>val res66: String = """[
  {
    "path":[
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"path",
          "_id":115964116994,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"char*",
          "lineNumber":51,
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"char* path",
          "columnNumber":17
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      }
    ]
  }
]"""
=~...
2025-06-09 13:49:12,219 - root - DEBUG - 添加数据流路径: Data flow: path (line 51) -> path (line 51)
2025-06-09 13:49:12,219 - root - INFO - 分析源 list_files 到汇聚点 list_files 的数据流结果: DataFlowResult(flows=[FlowPath(nodes=[FlowNode(node_id=115964116994, label='METHOD_PARAMETER_IN', code='char* path', line_number=51, column_number=17, type_full_name='char*', possible_types=[], dynamic_type_hint_full_name=[], name='path', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None)], is_vulnerable=False, confidence=0.0, vulnerability_type=None, description=None)], analysis_time=0.0, source=Source(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1))
2025-06-09 13:49:12,219 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:12,555 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("list_files").parameter.index(1)).toJsonPretty
>val res67: String = """[
  
]"""
=~...
2025-06-09 13:49:12,556 - root - INFO - 分析源 list_files 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:49:12,556 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:12,921 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.
.method.fullName("list_files").parameter.index(1)).toJsonPretty
>val res68: String = """[
  
]"""
=~...
2025-06-09 13:49:12,921 - root - INFO - 分析源 list_files 到汇聚点 system 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='system', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='system', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:12,921 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.method.fullName("list_files").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:13,247 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.m
method.fullName("list_files").parameter.index(1)).toJsonPretty
>val res69: String = """[
  
]"""
=~...
2025-06-09 13:49:13,248 - root - INFO - 分析源 list_files 到汇聚点 popen 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1), sink=Sink(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:13,248 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:49:13,564 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(c
cpg.method.fullName("main").methodReturn).toJsonPretty
>val res70: String = """[
  
]"""
=~...
2025-06-09 13:49:13,564 - root - INFO - 分析源 main 到汇聚点 execute_command 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=-1))
2025-06-09 13:49:13,565 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:49:13,879 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(
(cpg.method.fullName("main").methodReturn).toJsonPretty
>val res71: String = """[
  
]"""
=~...
2025-06-09 13:49:13,879 - root - INFO - 分析源 main 到汇聚点 list_files 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1))
2025-06-09 13:49:13,879 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:49:14,193 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("main").methodReturn).toJsonPretty
>val res72: String = """[
  
]"""
=~...
2025-06-09 13:49:14,193 - root - INFO - 分析源 main 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:49:14,193 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:49:14,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.
.method.fullName("main").methodReturn).toJsonPretty
>val res73: String = """[
  
]"""
=~...
2025-06-09 13:49:14,527 - root - INFO - 分析源 main 到汇聚点 system 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='system', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='system', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:14,527 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.method.fullName("main").methodReturn).toJsonPretty...
2025-06-09 13:49:14,856 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.m
method.fullName("main").methodReturn).toJsonPretty
>val res74: String = """[
  
]"""
=~...
2025-06-09 13:49:14,857 - root - INFO - 分析源 main 到汇聚点 popen 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=-1), sink=Sink(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:14,857 - root - ERROR - 分析源 fgets 到汇聚点 execute_command 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:14,857 - root - ERROR - 分析源 fgets 到汇聚点 list_files 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:14,857 - root - ERROR - 分析源 fgets 到汇聚点 main 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:14,857 - root - ERROR - 分析源 fgets 到汇聚点 system 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:14,857 - root - ERROR - 分析源 fgets 到汇聚点 popen 时出错: '>' not supported between instances of 'str' and 'int'
2025-06-09 13:49:14,857 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:15,193 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").methodReturn.reachableByDetailed(c
cpg.method.fullName("popen").parameter.index(1)).toJsonPretty
>val res75: String = """[
  
]"""
=~...
2025-06-09 13:49:15,194 - root - INFO - 分析源 popen 到汇聚点 execute_command 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1), sink=Sink(name='execute_command', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void execute_command(char* command) {\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', column_number=1, column_number_end=1, filename='command.c', full_name='execute_command', generic_signature='<empty>', hash_value=None, is_external=False, line_number=45, line_number_end=48, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=-1))
2025-06-09 13:49:15,194 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:15,538 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").parameter.index(1).reachableByDetailed(
(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty
>val res76: String = """[
  
]"""
=~...
2025-06-09 13:49:15,539 - root - INFO - 分析源 popen 到汇聚点 list_files 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1), sink=Sink(name='list_files', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}', column_number=1, column_number_end=22, filename='command.c', full_name='list_files', generic_signature='<empty>', hash_value=None, is_external=False, line_number=51, line_number_end=63, offset=None, offset_end=None, order=1, signature='void(char*)', parameters=None, useage=None, index=1))
2025-06-09 13:49:15,539 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:15,903 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").parameter.index(1).reachableByDetailed(cpg.me
ethod.fullName("popen").parameter.index(1)).toJsonPretty
>val res77: String = """[
  
]"""
=~...
2025-06-09 13:49:15,904 - root - INFO - 分析源 popen 到汇聚点 main 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1), sink=Sink(name='main', ast_parent_full_name='command.c:<global>', ast_parent_type='TYPE_DECL', code='int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}', column_number=1, column_number_end=1, filename='command.c', full_name='main', generic_signature='<empty>', hash_value=None, is_external=False, line_number=65, line_number_end=72, offset=None, offset_end=None, order=1, signature='int()', parameters=None, useage=None, index=1))
2025-06-09 13:49:15,904 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:16,240 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.index(1).reachableByDetailed(cpg.
.method.fullName("popen").parameter.index(1)).toJsonPretty
>val res78: String = """[
  
]"""
=~...
2025-06-09 13:49:16,240 - root - INFO - 分析源 popen 到汇聚点 system 的数据流结果: DataFlowResult(flows=[], analysis_time=0.0, source=Source(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1), sink=Sink(name='system', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='system', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:16,241 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.method.fullName("popen").parameter.index(1)).toJsonPretty...
2025-06-09 13:49:16,529 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.index(1).reachableByDetailed(cpg.m
method.fullName("popen").parameter.index(1)).toJsonPretty
>val res79: String = """[
  {
    "path":[
      {
        "node":{
          "dynamicTypeHintFullName":[
            
          ],
          "name":"p1",
          "_id":115964117035,
          "evaluationStrategy":"BY_VALUE",
          "isVariadic":false,
          "typeFullName":"ANY",
          "order":1,
          "_label":"METHOD_PARAMETER_IN",
          "possibleTypes":[
            
          ],
          "index":1,
          "code":"p1"
        },
        "callSiteStack":[
          
        ],
        "visible":true,
        "isOutputArg":false,
        "outEdgeLabel":""
      }
    ]
  }
]"""
=~...
2025-06-09 13:49:16,529 - root - DEBUG - 添加数据流路径: Data flow: p1 (line None) -> p1 (line None)
2025-06-09 13:49:16,529 - root - INFO - 分析源 popen 到汇聚点 popen 的数据流结果: DataFlowResult(flows=[FlowPath(nodes=[FlowNode(node_id=115964117035, label='METHOD_PARAMETER_IN', code='p1', line_number=None, column_number=None, type_full_name='ANY', possible_types=[], dynamic_type_hint_full_name=[], name='p1', order=1, index=1, evaluation_strategy='BY_VALUE', is_variadic=False, argument_index=None, signature=None, method_full_name=None, dispatch_type=None, call_site_stack=[], visible=True, is_output_arg=False, out_edge_label='', properties={}, methodContext=None, classContext=None)], is_vulnerable=False, confidence=0.0, vulnerability_type=None, description=None)], analysis_time=0.0, source=Source(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1), sink=Sink(name='popen', ast_parent_full_name='<global>', ast_parent_type='NAMESPACE_BLOCK', code='<empty>', column_number=None, column_number_end=None, filename='<empty>', full_name='popen', generic_signature='<empty>', hash_value=None, is_external=True, line_number=None, line_number_end=None, offset=None, offset_end=None, order=0, signature='', parameters=None, useage=None, index=1))
2025-06-09 13:49:16,530 - VulnerabilityEngine - INFO - Pass cwe78 执行成功，耗时: 290.21秒
2025-06-09 13:49:16,530 - VulnerabilityEngine - INFO - ✓ Pass cwe78 执行成功
2025-06-09 13:49:16,530 - VulnerabilityEngine - INFO -   未发现漏洞
2025-06-09 13:49:16,530 - VulnerabilityEngine - INFO - 
============================================================
2025-06-09 13:49:16,530 - VulnerabilityEngine - INFO - 分析完成 - 执行摘要
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - 总耗时: 465.50秒
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - 执行的passes: 2/2
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - 成功的passes: 2
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - 失败的passes: 0
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO - 总计发现漏洞: 0
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO -   - init: 成功 (175.29s, 0个发现)
2025-06-09 13:49:16,531 - VulnerabilityEngine - INFO -   - cwe78: 成功 (290.21s, 0个发现)
2025-06-09 13:49:16,532 - VulnerabilityEngine - INFO - 
保存分析结果...
2025-06-09 13:49:16,533 - VulnerabilityEngine - INFO - 分析结果已保存到: output/analysis_results_20250609_134916.json
2025-06-09 13:56:45,561 - VulnerabilityEngine - INFO - 初始化漏洞分析引擎 - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:56:45,561 - VulnerabilityEngine - DEBUG - 配置文件: /home/nstl/data/CPGvulnHunter/config.yml
2025-06-09 13:56:45,561 - VulnerabilityEngine - DEBUG - 启用的分析passes: ['init', 'cwe78']
2025-06-09 13:56:45,561 - VulnerabilityEngine - DEBUG - 最大调用深度: 20
2025-06-09 13:56:45,561 - VulnerabilityEngine - DEBUG - 并行执行: False
2025-06-09 13:56:45,561 - VulnerabilityEngine - INFO - 配置验证通过
2025-06-09 13:56:45,561 - VulnerabilityEngine - INFO - 开始初始化CPG...
2025-06-09 13:56:45,561 - CPGvulnHunter.core.cpg.CPG - INFO - 开始初始化CPG - 源路径: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:56:45,561 - CPGvulnHunter.core.cpg.CPG - DEBUG - 源路径验证通过: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:56:45,562 - CPGvulnHunter.core.cpg.CPG - INFO - 检测到目录，包含 1 个C源文件
2025-06-09 13:56:45,562 - CPGvulnHunter.core.cpg.CPG - INFO - 使用统一配置 - 项目: CPGvulnHunter, 版本: 1.0.0
2025-06-09 13:56:45,562 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化Joern包装器 - 安装路径: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/joern
2025-06-09 13:56:45,562 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - 启动Joern shell (尝试 1/3)
2025-06-09 13:56:50,339 - CPGvulnHunter.bridges.joernBridge.JoernBridge - INFO - Joern shell 启动成功
2025-06-09 13:56:50,339 - CPGvulnHunter.core.cpg.CPG - INFO - Joern包装器初始化成功
2025-06-09 13:56:50,340 - CPGvulnHunter.core.cpg.CPG - INFO - 初始化LLM包装器 - 模型: qwen2.5:14b
2025-06-09 13:56:50,340 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始初始化LLM Wrapper...
2025-06-09 13:56:50,340 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM配置 - 模型: qwen2.5:14b, 基础URL: http://192.168.5.253:3000/api/
2025-06-09 13:56:50,390 - CPGvulnHunter.bridges.llmWrapper - INFO - LLM Wrapper初始化成功，耗时: 0.05秒
2025-06-09 13:56:50,390 - CPGvulnHunter.bridges.llmWrapper - DEBUG - LLM客户端类型: LLMBridge
2025-06-09 13:56:50,390 - CPGvulnHunter.core.cpg.CPG - INFO - LLM包装器初始化成功
2025-06-09 13:56:50,390 - CPGvulnHunter.core.cpg.CPG - INFO - 开始导入代码到Joern创建CPG...
2025-06-09 13:56:50,390 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - INFO - 导入代码: /home/nstl/data/CPGvulnHunter/test/test_case/test2
2025-06-09 13:56:50,390 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test2")...
2025-06-09 13:56:52,869 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: importCode("/home/nstl/data/CPGvulnHunter/test/test_case/test2")
>Using generator for language: NEWC: CCpgGenerator
Creating project `test22` for code at `/home/nstl/data/CPGvulnHunter/test/test_case/test2`
=======================================================================================================
Invoking CPG generator in a separate process. Note that the new process will consume additional memory.
If you are importing a large codebase (and/or running into memory issues), please try the following:
1) exit joern
2) invoke the frontend: /home/nstl/data/vuln_hunter/heouJoern/joern/joern-cli/target/universal/stage/c2cpg.sh -J-Xmx30208m /home/nstl/data/CPGvulnHunter/test/test_case/test2 --output /home/nstl/data/CPGvulnHunter/workspace/test22/cpg.bin.zip
3) start joern, import the cpg: `importCpg("path/to/cpg")`
=======================================================================================================
moving cpg.bin.zip to cpg.bin because it is already a database file
Creating working copy of CPG to be safe
Loading base CPG from: /home/nstl/data/CPGvulnHunter/workspace/test22/cpg.bin.tmp
Code successfully imported. You can now query it using `cpg`.
For an overview of all imported code, type `workspace`.
Adding default overlays to base CPG
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
The graph has been modified. You may want to use the `save` command to persist changes to disk.  All changes will also be saved collectively on exit
val res0: io.shiftleft.codepropertygraph.generated.Cpg = Cpg[Graph[397 nodes]]
=~...
2025-06-09 13:56:52,869 - CPGvulnHunter.core.cpg.CPG - INFO - 代码导入完成，耗时: 2.48秒
2025-06-09 13:56:52,870 - CPGvulnHunter.core.cpg.CPG - INFO - CPG初始化完成
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO - CPG初始化完成，耗时: 7.31秒
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO - CPG统计信息:
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO -   - 总函数数: 0
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO -   - 内部函数数: 0
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO -   - 外部函数数: 0
2025-06-09 13:56:52,870 - VulnerabilityEngine - INFO -   - 操作符函数数: 0
2025-06-09 13:56:52,871 - VulnerabilityEngine - DEBUG - 输出目录: /home/nstl/data/CPGvulnHunter/output
2025-06-09 13:56:52,871 - VulnerabilityEngine - INFO - 引擎初始化完成
2025-06-09 13:56:52,871 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:56:52,871 - VulnerabilityEngine - INFO - 开始执行漏洞分析
2025-06-09 13:56:52,871 - VulnerabilityEngine - INFO - ============================================================
2025-06-09 13:56:52,871 - VulnerabilityEngine - INFO - 分析配置:
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO -   - 启用的passes: ['init', 'cwe78'] (共 2 个)
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO -   - 并行执行: False
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO -   - 每个pass超时: 300秒
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO -   - 最大函数数: 1000
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO - 
--- 执行Pass 1/2: init ---
2025-06-09 13:56:52,872 - VulnerabilityEngine - INFO - 执行Pass: init
2025-06-09 13:56:52,872 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName.toJsonPretty...
2025-06-09 13:56:53,531 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName.toJsonPretty
>val res1: String = """[
  "get_user_input",
  "command.c:<global>",
  "basic_validate",
  "execute_command",
  "list_files",
  "main",
  "<includes>:<global>",
  "<operator>.assignment",
  "<operator>.alloc",
  "command.c:6:6:MAX_BUFFER:0",
  "printf",
  "fgets",
  "<operator>.sizeOf",
  "strlen",
  "<operator>.logicalAnd",
  "<operator>.greaterThan",
  "<operator>.equals",
  "<operator>.indirectIndexAccess",
  "<operator>.subtraction",
  "strcpy",
  "<operator>.arrayInitializer",
  "<operator>.division",
  "<operator>.lessThan",
  "<operator>.postIncrement",
  "strstr",
  "memset",
  "system",
  "snprintf",
  "popen",
  "pclose"
]"""
=~...
2025-06-09 13:56:53,531 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total function full names found: 30
2025-06-09 13:56:53,532 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("get_user_input").toJsonPretty...
2025-06-09 13:56:53,946 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("get_user_input").toJsonPretty
>val res2: String = """[
  {
    "name":"get_user_input",
    "astParentFullName":"command.c:<global>",
    "_id":111669149696,
    "signature":"char*()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":25,
    "_label":"METHOD",
    "columnNumberEnd":29,
    "fullName":"get_user_input",
    "genericSignature":"<empty>",
    "code":"char* get_user_input() {\n    static char input_buffer[MAX_BUFFER];\n    printf(\"请输入文件名: \");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == '\\n') {\n        input_buffer[len-1] = '\\0';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}",
    "isExternal":false,
    "lineNumber":13,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:53,947 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:<global>").toJsonPretty...
2025-06-09 13:56:54,338 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:<global>").toJsonPretty
>val res3: String = """[
  {
    "name":"<global>",
    "astParentFullName":"command.c:<global>",
    "_id":111669149697,
    "signature":"",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":72,
    "_label":"METHOD",
    "columnNumberEnd":29,
    "fullName":"command.c:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:54,339 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("basic_validate").toJsonPretty...
2025-06-09 13:56:54,703 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("basic_validate").toJsonPretty
>val res4: String = """[
  {
    "name":"basic_validate",
    "astParentFullName":"command.c:<global>",
    "_id":111669149698,
    "signature":"char*(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":42,
    "_label":"METHOD",
    "columnNumberEnd":26,
    "fullName":"basic_validate",
    "genericSignature":"<empty>",
    "code":"char* basic_validate(char* input) {\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {\"rm\", \"del\"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, 'X', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}",
    "isExternal":false,
    "lineNumber":27,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:54,703 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("execute_command").toJsonPretty...
2025-06-09 13:56:55,098 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("execute_command").toJsonPretty
>val res5: String = """[
  {
    "name":"execute_command",
    "astParentFullName":"command.c:<global>",
    "_id":111669149699,
    "signature":"void(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":48,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"execute_command",
    "genericSignature":"<empty>",
    "code":"void execute_command(char* command) {\n    printf(\"执行命令: %s\\n\", command);\n    system(command);  \n}",
    "isExternal":false,
    "lineNumber":45,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:55,098 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("list_files").toJsonPretty...
2025-06-09 13:56:55,466 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("list_files").toJsonPretty
>val res6: String = """[
  {
    "name":"list_files",
    "astParentFullName":"command.c:<global>",
    "_id":111669149700,
    "signature":"void(char*)",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":63,
    "_label":"METHOD",
    "columnNumberEnd":22,
    "fullName":"list_files",
    "genericSignature":"<empty>",
    "code":"void list_files(char* path) {\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), \"ls %s\", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, \"r\");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf(\"文件: %s\", output);\n        }\n        pclose(pipe);\n    }\n}",
    "isExternal":false,
    "lineNumber":51,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:55,467 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("main").toJsonPretty...
2025-06-09 13:56:55,754 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("main").toJsonPretty
>val res7: String = """[
  {
    "name":"main",
    "astParentFullName":"command.c:<global>",
    "_id":111669149701,
    "signature":"int()",
    "astParentType":"TYPE_DECL",
    "lineNumberEnd":72,
    "_label":"METHOD",
    "columnNumberEnd":1,
    "fullName":"main",
    "genericSignature":"<empty>",
    "code":"int main() {\n\n    char* user_path = get_user_input();              // SOURCE\n    char* validated_path = basic_validate(user_path); // SANITIZER\n    list_files(validated_path);                      // SINK\n    \n    return 0;\n}",
    "isExternal":false,
    "lineNumber":65,
    "columnNumber":1,
    "order":1,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:55,755 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<includes>:<global>").toJsonPretty...
2025-06-09 13:56:56,068 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<includes>:<global>").toJsonPretty
>val res8: String = """[
  {
    "name":"<global>",
    "astParentFullName":"<includes>:<global>",
    "_id":111669149702,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<includes>:<global>",
    "genericSignature":"<empty>",
    "code":"<global>",
    "isExternal":false,
    "lineNumber":1,
    "order":1,
    "filename":"<includes>"
  }
]"""
=~...
2025-06-09 13:56:56,069 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.assignment").toJsonPretty...
2025-06-09 13:56:56,405 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.assignment").toJsonPretty
>val res9: String = """[
  {
    "name":"<operator>.assignment",
    "astParentFullName":"<global>",
    "_id":111669149703,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.assignment",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:56:56,405 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.alloc").toJsonPretty...
2025-06-09 13:56:56,755 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.alloc").toJsonPretty
>val res10: String = """[
  {
    "name":"<operator>.alloc",
    "astParentFullName":"<global>",
    "_id":111669149704,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.alloc",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:56:56,756 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").toJsonPretty...
2025-06-09 13:56:57,091 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").toJsonPretty
>val res11: String = """[
  {
    "name":"MAX_BUFFER",
    "astParentFullName":"<global>",
    "_id":111669149705,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "lineNumberEnd":6,
    "_label":"METHOD",
    "fullName":"command.c:6:6:MAX_BUFFER:0",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "lineNumber":6,
    "order":0,
    "filename":"command.c"
  }
]"""
=~...
2025-06-09 13:56:57,091 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").parameter.toJsonPretty...
2025-06-09 13:56:57,455 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("command.c:6:6:MAX_BUFFER:0").parameter.toJsonPretty
>val res12: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p0",
    "_id":115964116998,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":0,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":0,
    "code":"p0"
  }
]"""
=~...
2025-06-09 13:56:57,810 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 的使用情况: ['input_buffer[MAX_BUFFER]', 'validated[MAX_BUFFER]', 'full_command[MAX_BUFFER]']
2025-06-09 13:56:57,811 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").toJsonPretty...
2025-06-09 13:56:58,148 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").toJsonPretty
>val res14: String = """[
  {
    "name":"printf",
    "astParentFullName":"<global>",
    "_id":111669149706,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"printf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:56:58,148 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("printf").parameter.toJsonPretty...
2025-06-09 13:56:58,462 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("printf").parameter.toJsonPretty
>val res15: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964116999,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117000,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:56:58,785 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 printf 的使用情况: ['{\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}', '{\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}', '{\n            printf("文件: %s", output);\n        }']
2025-06-09 13:56:58,785 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").toJsonPretty...
2025-06-09 13:56:59,098 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").toJsonPretty
>val res17: String = """[
  {
    "name":"fgets",
    "astParentFullName":"<global>",
    "_id":111669149707,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"fgets",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:56:59,099 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("fgets").parameter.toJsonPretty...
2025-06-09 13:56:59,439 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("fgets").parameter.toJsonPretty
>val res18: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117001,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117002,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117003,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:56:59,770 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 fgets 的使用情况: ['{\n    static char input_buffer[MAX_BUFFER];\n    printf("请输入文件名: ");\n    fgets(input_buffer, sizeof(input_buffer), stdin);\n    \n    // 移除换行符\n    size_t len = strlen(input_buffer);\n    if (len > 0 && input_buffer[len-1] == \'\\n\') {\n        input_buffer[len-1] = \'\\0\';\n    }\n    \n    return input_buffer;  // 返回值是 SOURCE\n}', 'while (fgets(output, sizeof(output), pipe))']
2025-06-09 13:56:59,770 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.sizeOf").toJsonPretty...
2025-06-09 13:57:00,117 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.sizeOf").toJsonPretty
>val res20: String = """[
  {
    "name":"<operator>.sizeOf",
    "astParentFullName":"<global>",
    "_id":111669149708,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.sizeOf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:00,118 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strlen").toJsonPretty...
2025-06-09 13:57:00,456 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strlen").toJsonPretty
>val res21: String = """[
  {
    "name":"strlen",
    "astParentFullName":"<global>",
    "_id":111669149709,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strlen",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:00,457 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strlen").parameter.toJsonPretty...
2025-06-09 13:57:00,780 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strlen").parameter.toJsonPretty
>val res22: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117005,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:57:01,117 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strlen 的使用情况: ['len = strlen(input_buffer)', "memset(pos, 'X', strlen(dangerous[i]))"]
2025-06-09 13:57:01,118 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.logicalAnd").toJsonPretty...
2025-06-09 13:57:01,419 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.logicalAnd").toJsonPretty
>val res24: String = """[
  {
    "name":"<operator>.logicalAnd",
    "astParentFullName":"<global>",
    "_id":111669149710,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.logicalAnd",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:01,419 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.greaterThan").toJsonPretty...
2025-06-09 13:57:01,750 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.greaterThan").toJsonPretty
>val res25: String = """[
  {
    "name":"<operator>.greaterThan",
    "astParentFullName":"<global>",
    "_id":111669149711,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.greaterThan",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:01,750 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.equals").toJsonPretty...
2025-06-09 13:57:02,072 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.equals").toJsonPretty
>val res26: String = """[
  {
    "name":"<operator>.equals",
    "astParentFullName":"<global>",
    "_id":111669149712,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.equals",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:02,073 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.indirectIndexAccess").toJsonPretty...
2025-06-09 13:57:02,381 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.indirectIndexAccess").toJsonPretty
>val res27: String = """[
  {
    "name":"<operator>.indirectIndexAccess",
    "astParentFullName":"<global>",
    "_id":111669149713,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.indirectIndexAccess",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:02,382 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.subtraction").toJsonPretty...
2025-06-09 13:57:02,697 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.subtraction").toJsonPretty
>val res28: String = """[
  {
    "name":"<operator>.subtraction",
    "astParentFullName":"<global>",
    "_id":111669149714,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.subtraction",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:02,697 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strcpy").toJsonPretty...
2025-06-09 13:57:03,027 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strcpy").toJsonPretty
>val res29: String = """[
  {
    "name":"strcpy",
    "astParentFullName":"<global>",
    "_id":111669149715,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strcpy",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:03,027 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strcpy").parameter.toJsonPretty...
2025-06-09 13:57:03,347 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strcpy").parameter.toJsonPretty
>val res30: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117016,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117017,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:57:03,672 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strcpy 的使用情况: ['{\n    static char validated[MAX_BUFFER];\n    strcpy(validated, input);\n    \n    char* dangerous[] = {"rm", "del"};\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\n    \n    for (int i = 0; i < dangerous_count; i++) {\n        char* pos = strstr(validated, dangerous[i]);\n        if (pos) {\n            memset(pos, \'X\', strlen(dangerous[i]));\n        }\n    }\n    \n    return validated;\n}']
2025-06-09 13:57:03,672 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.arrayInitializer").toJsonPretty...
2025-06-09 13:57:03,977 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.arrayInitializer").toJsonPretty
>val res32: String = """[
  {
    "name":"<operator>.arrayInitializer",
    "astParentFullName":"<global>",
    "_id":111669149716,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.arrayInitializer",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:03,978 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.division").toJsonPretty...
2025-06-09 13:57:04,300 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.division").toJsonPretty
>val res33: String = """[
  {
    "name":"<operator>.division",
    "astParentFullName":"<global>",
    "_id":111669149717,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.division",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:04,301 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.lessThan").toJsonPretty...
2025-06-09 13:57:04,621 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.lessThan").toJsonPretty
>val res34: String = """[
  {
    "name":"<operator>.lessThan",
    "astParentFullName":"<global>",
    "_id":111669149718,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.lessThan",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:04,621 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("<operator>.postIncrement").toJsonPretty...
2025-06-09 13:57:04,934 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("<operator>.postIncrement").toJsonPretty
>val res35: String = """[
  {
    "name":"<operator>.postIncrement",
    "astParentFullName":"<global>",
    "_id":111669149719,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"<operator>.postIncrement",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:04,934 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strstr").toJsonPretty...
2025-06-09 13:57:05,261 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strstr").toJsonPretty
>val res36: String = """[
  {
    "name":"strstr",
    "astParentFullName":"<global>",
    "_id":111669149720,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"strstr",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:05,262 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("strstr").parameter.toJsonPretty...
2025-06-09 13:57:05,584 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("strstr").parameter.toJsonPretty
>val res37: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117025,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117026,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:57:05,899 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 strstr 的使用情况: ['* pos = strstr(validated, dangerous[i])']
2025-06-09 13:57:05,899 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("memset").toJsonPretty...
2025-06-09 13:57:06,202 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("memset").toJsonPretty
>val res39: String = """[
  {
    "name":"memset",
    "astParentFullName":"<global>",
    "_id":111669149721,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"memset",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:06,202 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("memset").parameter.toJsonPretty...
2025-06-09 13:57:06,526 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("memset").parameter.toJsonPretty
>val res40: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117027,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117028,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117029,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  }
]"""
=~...
2025-06-09 13:57:06,862 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 memset 的使用情况: ["{\n            memset(pos, 'X', strlen(dangerous[i]));\n        }"]
2025-06-09 13:57:06,862 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").toJsonPretty...
2025-06-09 13:57:07,187 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").toJsonPretty
>val res42: String = """[
  {
    "name":"system",
    "astParentFullName":"<global>",
    "_id":111669149722,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"system",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:07,188 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("system").parameter.toJsonPretty...
2025-06-09 13:57:07,492 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("system").parameter.toJsonPretty
>val res43: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117030,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:57:07,811 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 system 的使用情况: ['{\n    printf("执行命令: %s\\n", command);\n    system(command);  \n}']
2025-06-09 13:57:07,811 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("snprintf").toJsonPretty...
2025-06-09 13:57:08,126 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("snprintf").toJsonPretty
>val res45: String = """[
  {
    "name":"snprintf",
    "astParentFullName":"<global>",
    "_id":111669149723,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"snprintf",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:08,127 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("snprintf").parameter.toJsonPretty...
2025-06-09 13:57:08,432 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("snprintf").parameter.toJsonPretty
>val res46: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117031,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117032,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p3",
    "_id":115964117033,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":3,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":3,
    "code":"p3"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p4",
    "_id":115964117034,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":4,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":4,
    "code":"p4"
  }
]"""
=~...
2025-06-09 13:57:08,760 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 snprintf 的使用情况: ['{\n    char full_command[MAX_BUFFER];\n    snprintf(full_command, sizeof(full_command), "ls %s", path);  // path 参数是 SINK\n    \n    FILE* pipe = popen(full_command, "r");\n    if (pipe) {\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }\n}']
2025-06-09 13:57:08,760 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").toJsonPretty...
2025-06-09 13:57:09,078 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").toJsonPretty
>val res48: String = """[
  {
    "name":"popen",
    "astParentFullName":"<global>",
    "_id":111669149724,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"popen",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:09,078 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("popen").parameter.toJsonPretty...
2025-06-09 13:57:09,399 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("popen").parameter.toJsonPretty
>val res49: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117035,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  },
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p2",
    "_id":115964117036,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":2,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":2,
    "code":"p2"
  }
]"""
=~...
2025-06-09 13:57:09,753 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 popen 的使用情况: ['* pipe = popen(full_command, "r")']
2025-06-09 13:57:09,754 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("pclose").toJsonPretty...
2025-06-09 13:57:10,051 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("pclose").toJsonPretty
>val res51: String = """[
  {
    "name":"pclose",
    "astParentFullName":"<global>",
    "_id":111669149725,
    "signature":"",
    "astParentType":"NAMESPACE_BLOCK",
    "_label":"METHOD",
    "fullName":"pclose",
    "genericSignature":"<empty>",
    "code":"<empty>",
    "isExternal":true,
    "order":0,
    "filename":"<empty>"
  }
]"""
=~...
2025-06-09 13:57:10,052 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 执行命令: cpg.method.fullName("pclose").parameter.toJsonPretty...
2025-06-09 13:57:10,361 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 命令结果: cpg.method.fullName("pclose").parameter.toJsonPretty
>val res52: String = """[
  {
    "dynamicTypeHintFullName":[
      
    ],
    "name":"p1",
    "_id":115964117037,
    "evaluationStrategy":"BY_VALUE",
    "isVariadic":false,
    "typeFullName":"ANY",
    "order":1,
    "_label":"METHOD_PARAMETER_IN",
    "possibleTypes":[
      
    ],
    "index":1,
    "code":"p1"
  }
]"""
=~...
2025-06-09 13:57:10,689 - CPGvulnHunter.bridges.joernWrapper.JoernWrapper - DEBUG - 函数 pclose 的使用情况: ['{\n        char output[256];\n        while (fgets(output, sizeof(output), pipe)) {\n            printf("文件: %s", output);\n        }\n        pclose(pipe);\n    }']
2025-06-09 13:57:10,689 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total functions found: 18
2025-06-09 13:57:10,689 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total external functions found: 11
2025-06-09 13:57:10,689 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total internal functions found: 7
2025-06-09 13:57:10,689 - CPGvulnHunter.passes.initPass.InitPass - INFO - Total operator functions found: 12
2025-06-09 13:57:10,689 - CPGvulnHunter.bridges.llmWrapper - INFO - 开始逐个分析 11 个外部函数
2025-06-09 13:57:10,689 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 1/11: command.c:6:6:MAX_BUFFER:0
2025-06-09 13:57:10,690 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: command.c:6:6:MAX_BUFFER:0
2025-06-09 13:57:10,690 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 command.c:6:6:MAX_BUFFER:0 构建分析请求完成
2025-06-09 13:57:10,690 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: command.c:6:6:MAX_BUFFER:0\n函数签名: 未知签名\n函数用法: [\'input_buffer[MAX_BUFFER]\', \'validated[MAX_BUFFER]\', \'full_command[MAX_BUFFER]\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "command.c:6:6:MAX_BUFFER:0",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:57:10,690 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:57:10,828 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-c8b20df9-48b6-4478-9374-b0a5601e68ec', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: command.c:6:6:MAX_BUFFER:0\n函数签名: 未知签名\n函数用法: [\'input_buffer[MAX_BUFFER]\', \'validated[MAX_BUFFER]\', \'full_command[MAX_BUFFER]\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "command.c:6:6:MAX_BUFFER:0",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:57:10,831 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:57:10,831 - httpcore.connection - DEBUG - connect_tcp.started host='192.168.5.253' port=3000 local_address=None timeout=5.0 socket_options=None
2025-06-09 13:57:10,833 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x714e43404650>
2025-06-09 13:57:10,833 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:57:10,833 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:57:10,833 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:57:10,833 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:57:10,834 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:57:53,104 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:57:09 GMT'), (b'server', b'uvicorn'), (b'content-length', b'936'), (b'content-type', b'application/json'), (b'x-process-time', b'43')])
2025-06-09 13:57:53,104 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:57:53,105 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:57:53,105 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:57:53,105 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:57:53,105 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:57:53,105 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:57:09 GMT', 'server': 'uvicorn', 'content-length': '936', 'content-type': 'application/json', 'x-process-time': '43'})
2025-06-09 13:57:53,105 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:57:53,107 - root - DEBUG - 正在提取JSON，原始文本长度: 199, 清理后长度: 199
2025-06-09 13:57:53,107 - root - DEBUG - 直接解析成功
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 LLM请求完成，耗时: 42.42秒
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 原始参数流数据: []
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 command.c:6:6:MAX_BUFFER:0 语义规则生成成功 - 参数流数量: 0, 置信度: high
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 command.c:6:6:MAX_BUFFER:0 分析依据: 函数签名未知且未提供具体实现，无法确定参数间的数据流动关系
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 command.c:6:6:MAX_BUFFER:0 分析成功，耗时: 42.42秒
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 2/11: printf
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: printf
2025-06-09 13:57:53,107 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 printf 构建分析请求完成
2025-06-09 13:57:53,107 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\', \'{\\n            printf("文件: %s", output);\\n        }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:57:53,107 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:57:53,108 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-71a15659-4321-4c1b-a327-48b5a02cb9ea', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: printf\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\', \'{\\n            printf("文件: %s", output);\\n        }\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "printf",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:57:53,108 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:57:53,109 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:57:53,109 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:57:53,109 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:57:53,109 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:57:53,109 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:04,364 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:57:52 GMT'), (b'server', b'uvicorn'), (b'content-length', b'972'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:58:04,364 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:04,364 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:04,364 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:04,365 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:04,365 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:04,365 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:57:52 GMT', 'server': 'uvicorn', 'content-length': '972', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:58:04,365 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:04,365 - root - DEBUG - 正在提取JSON，原始文本长度: 229, 清理后长度: 229
2025-06-09 13:58:04,365 - root - DEBUG - 直接解析成功
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf LLM请求完成，耗时: 11.26秒
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 添加参数流 1: 2 -> -1
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 printf 分析依据: printf函数将格式化后的输出数据流向外部，可能涉及安全关键的数据流。
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 printf 分析成功，耗时: 11.26秒
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 3/11: fgets
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: fgets
2025-06-09 13:58:04,366 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 fgets 构建分析请求完成
2025-06-09 13:58:04,366 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'while (fgets(output, sizeof(output), pipe))\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:04,366 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:04,367 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-597a3a88-2f21-4f93-8058-dbf1ba39b430', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: fgets\n函数签名: 未知签名\n函数用法: [\'{\\n    static char input_buffer[MAX_BUFFER];\\n    printf("请输入文件名: ");\\n    fgets(input_buffer, sizeof(input_buffer), stdin);\\n    \\n    // 移除换行符\\n    size_t len = strlen(input_buffer);\\n    if (len > 0 && input_buffer[len-1] == \\\'\\\\n\\\') {\\n        input_buffer[len-1] = \\\'\\\\0\\\';\\n    }\\n    \\n    return input_buffer;  // 返回值是 SOURCE\\n}\', \'while (fgets(output, sizeof(output), pipe))\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "fgets",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:04,368 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:04,368 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:04,368 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:04,368 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:04,368 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:04,368 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:15,881 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:58:04 GMT'), (b'server', b'uvicorn'), (b'content-length', b'959'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:58:15,881 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:15,881 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:15,881 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:15,882 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:15,882 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:15,882 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:58:04 GMT', 'server': 'uvicorn', 'content-length': '959', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:58:15,882 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:15,883 - root - DEBUG - 正在提取JSON，原始文本长度: 221, 清理后长度: 221
2025-06-09 13:58:15,883 - root - DEBUG - 直接解析成功
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets LLM请求完成，耗时: 11.52秒
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 原始参数流数据: [{'from': 3, 'to': 1}]
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 添加参数流 1: 3 -> 1
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 fgets 分析依据: 根据函数签名和用法，数据从流（参数3）流向缓冲区（参数1）。
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 fgets 分析成功，耗时: 11.52秒
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 4/11: strlen
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strlen
2025-06-09 13:58:15,883 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strlen 构建分析请求完成
2025-06-09 13:58:15,883 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strlen\n函数签名: 未知签名\n函数用法: [\'len = strlen(input_buffer)\', "memset(pos, \'X\', strlen(dangerous[i]))"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strlen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:15,883 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:15,884 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-8a2897ff-fc0e-4bb0-99ed-9785b7d0628b', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strlen\n函数签名: 未知签名\n函数用法: [\'len = strlen(input_buffer)\', "memset(pos, \'X\', strlen(dangerous[i]))"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strlen",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:15,885 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:15,885 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:15,886 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:15,886 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:15,886 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:15,886 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:25,573 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:58:15 GMT'), (b'server', b'uvicorn'), (b'content-length', b'939'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:58:25,574 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:25,574 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:25,574 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:25,574 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:25,575 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:25,575 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:58:15 GMT', 'server': 'uvicorn', 'content-length': '939', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:58:25,575 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:25,575 - root - DEBUG - 正在提取JSON，原始文本长度: 193, 清理后长度: 193
2025-06-09 13:58:25,576 - root - DEBUG - 直接解析成功
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen LLM请求完成，耗时: 9.69秒
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen 原始参数流数据: []
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strlen 语义规则生成成功 - 参数流数量: 0, 置信度: high
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strlen 分析依据: strlen 函数不涉及参数之间的数据传递关系，其主要功能是计算字符串长度并返回结果。
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strlen 分析成功，耗时: 9.69秒
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 5/11: strcpy
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strcpy
2025-06-09 13:58:25,576 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strcpy 构建分析请求完成
2025-06-09 13:58:25,576 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strcpy\n函数签名: 未知签名\n函数用法: [\'{\\n    static char validated[MAX_BUFFER];\\n    strcpy(validated, input);\\n    \\n    char* dangerous[] = {"rm", "del"};\\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\\n    \\n    for (int i = 0; i < dangerous_count; i++) {\\n        char* pos = strstr(validated, dangerous[i]);\\n        if (pos) {\\n            memset(pos, \\\'X\\\', strlen(dangerous[i]));\\n        }\\n    }\\n    \\n    return validated;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strcpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:25,577 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:25,578 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-8cddc187-d557-461e-98ef-6dfc54750aff', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strcpy\n函数签名: 未知签名\n函数用法: [\'{\\n    static char validated[MAX_BUFFER];\\n    strcpy(validated, input);\\n    \\n    char* dangerous[] = {"rm", "del"};\\n    int dangerous_count = sizeof(dangerous) / sizeof(dangerous[0]);\\n    \\n    for (int i = 0; i < dangerous_count; i++) {\\n        char* pos = strstr(validated, dangerous[i]);\\n        if (pos) {\\n            memset(pos, \\\'X\\\', strlen(dangerous[i]));\\n        }\\n    }\\n    \\n    return validated;\\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strcpy",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:25,579 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:25,579 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:25,579 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:25,579 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:25,579 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:25,580 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:36,881 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:58:25 GMT'), (b'server', b'uvicorn'), (b'content-length', b'940'), (b'content-type', b'application/json'), (b'x-process-time', b'11')])
2025-06-09 13:58:36,882 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:36,882 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:36,883 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:36,883 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:36,883 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:36,883 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:58:25 GMT', 'server': 'uvicorn', 'content-length': '940', 'content-type': 'application/json', 'x-process-time': '11'})
2025-06-09 13:58:36,884 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:36,885 - root - DEBUG - 正在提取JSON，原始文本长度: 218, 清理后长度: 218
2025-06-09 13:58:36,885 - root - DEBUG - 直接解析成功
2025-06-09 13:58:36,885 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy LLM请求完成，耗时: 11.31秒
2025-06-09 13:58:36,885 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-09 13:58:36,885 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 添加参数流 1: 2 -> 1
2025-06-09 13:58:36,885 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strcpy 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:58:36,885 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strcpy 分析依据: 根据函数签名和用法，strcpy从源参数流向目标参数
2025-06-09 13:58:36,886 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strcpy 分析成功，耗时: 11.31秒
2025-06-09 13:58:36,886 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 6/11: strstr
2025-06-09 13:58:36,886 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: strstr
2025-06-09 13:58:36,886 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 strstr 构建分析请求完成
2025-06-09 13:58:36,886 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strstr\n函数签名: 未知签名\n函数用法: [\'* pos = strstr(validated, dangerous[i])\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strstr",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:36,886 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:36,888 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-3a59e8bb-1da6-4e8b-b581-6255a6eed1e7', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: strstr\n函数签名: 未知签名\n函数用法: [\'* pos = strstr(validated, dangerous[i])\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "strstr",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:36,890 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:36,890 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:36,891 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:36,891 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:36,891 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:36,891 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:48,432 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:58:36 GMT'), (b'server', b'uvicorn'), (b'content-length', b'1101'), (b'content-type', b'application/json'), (b'x-process-time', b'12')])
2025-06-09 13:58:48,433 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:48,434 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:48,434 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:48,434 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:48,434 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:48,434 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:58:36 GMT', 'server': 'uvicorn', 'content-length': '1101', 'content-type': 'application/json', 'x-process-time': '12'})
2025-06-09 13:58:48,435 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:48,436 - root - DEBUG - 正在提取JSON，原始文本长度: 293, 清理后长度: 293
2025-06-09 13:58:48,436 - root - DEBUG - 直接解析成功
2025-06-09 13:58:48,436 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr LLM请求完成，耗时: 11.55秒
2025-06-09 13:58:48,436 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 原始参数流数据: [{'from': 2, 'to': -1}]
2025-06-09 13:58:48,436 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 添加参数流 1: 2 -> -1
2025-06-09 13:58:48,436 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strstr 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:58:48,437 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 strstr 分析依据: 函数strstr的主要作用是在第一个参数validated中查找第二个参数dangerous[i]的首次出现。返回值指向找到的子字符串在validated中的位置，因此数据流是从第2个参数流向返回值。
2025-06-09 13:58:48,437 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 strstr 分析成功，耗时: 11.55秒
2025-06-09 13:58:48,437 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 7/11: memset
2025-06-09 13:58:48,437 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: memset
2025-06-09 13:58:48,437 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 memset 构建分析请求完成
2025-06-09 13:58:48,437 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: memset\n函数签名: 未知签名\n函数用法: ["{\\n            memset(pos, \'X\', strlen(dangerous[i]));\\n        }"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "memset",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:48,437 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:48,439 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-1fbf2bcf-805f-46d3-8b54-782b651967d7', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: memset\n函数签名: 未知签名\n函数用法: ["{\\n            memset(pos, \'X\', strlen(dangerous[i]));\\n        }"]\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "memset",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:48,441 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:48,441 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:48,441 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:48,442 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:48,442 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:48,442 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-06-09 13:58:58,839 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'date', b'Mon, 09 Jun 2025 05:58:48 GMT'), (b'server', b'uvicorn'), (b'content-length', b'957'), (b'content-type', b'application/json'), (b'x-process-time', b'10')])
2025-06-09 13:58:58,839 - httpx - INFO - HTTP Request: POST http://192.168.5.253:3000/api/chat/completions "HTTP/1.1 200 OK"
2025-06-09 13:58:58,839 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-06-09 13:58:58,839 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-06-09 13:58:58,840 - httpcore.http11 - DEBUG - response_closed.started
2025-06-09 13:58:58,840 - httpcore.http11 - DEBUG - response_closed.complete
2025-06-09 13:58:58,840 - openai._base_client - DEBUG - HTTP Response: POST http://192.168.5.253:3000/api/chat/completions "200 OK" Headers({'date': 'Mon, 09 Jun 2025 05:58:48 GMT', 'server': 'uvicorn', 'content-length': '957', 'content-type': 'application/json', 'x-process-time': '10'})
2025-06-09 13:58:58,840 - openai._base_client - DEBUG - request_id: None
2025-06-09 13:58:58,840 - root - DEBUG - 正在提取JSON，原始文本长度: 225, 清理后长度: 225
2025-06-09 13:58:58,840 - root - DEBUG - 直接解析成功
2025-06-09 13:58:58,840 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset LLM请求完成，耗时: 10.40秒
2025-06-09 13:58:58,840 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 原始参数流数据: [{'from': 2, 'to': 1}]
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 添加参数流 1: 2 -> 1
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 memset 语义规则生成成功 - 参数流数量: 1, 置信度: high
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 函数 memset 分析依据: 函数memset的第2个参数（字符值）流向第1个参数（目标地址）。
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - INFO - 函数 memset 分析成功，耗时: 10.40秒
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - INFO - 正在分析函数 8/11: system
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 开始分析函数: system
2025-06-09 13:58:58,841 - CPGvulnHunter.bridges.llmWrapper - DEBUG - 为函数 system 构建分析请求完成
2025-06-09 13:58:58,841 - root - DEBUG - 发送消息: [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: system\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "system",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}]
2025-06-09 13:58:58,841 - root - DEBUG - 使用模型: qwen2.5:14b, 温度: 0.1, top_p: 0.1, 最大token数: 4000
2025-06-09 13:58:58,842 - openai._base_client - DEBUG - Request options: {'method': 'post', 'url': '/chat/completions', 'files': None, 'idempotency_key': 'stainless-python-retry-fb43b3e0-43d1-4367-9bd7-2d2a59ff1659', 'json_data': {'messages': [{'role': 'system', 'content': '你是一位资深的程序静态分析专家，专精于代码语义理解和数据流分析。你具备深厚的漏洞挖掘经验，能够准确识别函数间的数据流动模式，并为Joern静态分析框架生成精确的语义规则。\n\n**重要提示：请严格按照要求，只返回JSON格式的结果，不要包含任何解释文字、说明文档或代码块标记。**'}, {'role': 'user', 'content': '请为以下函数生成Joern静态分析框架所需的语义规则，重点分析参数间的数据流动关系。\n\n## 目标函数信息\n函数名: system\n函数签名: 未知签名\n函数用法: [\'{\\n    printf("执行命令: %s\\\\n", command);\\n    system(command);  \\n}\']\n\n## 分析任务\n1. **数据流分析**: 识别函数参数之间的数据传递关系\n2. **污点传播**: 确定哪些参数会将数据传递给其他参数或返回值\n3. **语义规则生成**: 生成符合Joern框架的参数流映射规则\n\n## 参数索引约定\n- **-1**: 函数返回值\n- **0**: 对象实例本身（this/self，适用于面向对象方法）\n- **1, 2, 3...**: 函数参数按顺序编号（从1开始）\n\n## 数据流分析原则\n**重要：数据流表示的是污点数据的传播方向，即数据从哪里来到哪里去**\n\n### 常见函数的数据流模式：\n- **输入函数**（如 `fgets`, `scanf`, `read`）: 从数据源流向目标缓冲区\n  - `fgets(buffer, size, stream)`: 数据从 stream(参数3) 流向 buffer(参数1) → `{"from": 3, "to": 1}`\n- **复制函数**（如 `strcpy`, `memcpy`）: 从源流向目标\n  - `strcpy(dest, src)`: 数据从 src(参数2) 流向 dest(参数1) → `{"from": 2, "to": 1}`\n- **返回函数**（如 `malloc`, `strdup`）: 函数内部创建的数据流向返回值\n  - `malloc(size)`: 分配的内存通过返回值返回 → `{"from": 1, "to": -1}`\n- **格式化函数**（如 `sprintf`, `printf`）: 从格式化参数流向输出\n  - `sprintf(buffer, format, ...)`: 格式化内容流向 buffer → `{"from": 2, "to": 1}`\n\n## 数据流表示\n- **from**: 源参数索引（数据来源）\n- **to**: 目标参数索引（数据去向）\n- 例如: `{"from": 2, "to": 1}` 表示第2个参数的数据流向第1个参数\n\n## 特殊情况处理\n- 如果函数不涉及数据传递，返回空的 param_flows 数组\n- 如果函数有多个数据流路径，包含所有相关的流向\n- 优先考虑安全关键的数据流（可能导致漏洞的流向）\n\n## 严格要求\n**请直接返回以下JSON格式的内容，不要添加任何解释文字、前言、后缀说明或代码块标记（如```json）：**\n\n{\n    "analysis_result": {\n        "function_name": "system",\n        "param_flows": [\n            {"from": 源参数索引, "to": 目标参数索引},\n            ...\n        ],\n        "confidence": "high|medium|low",\n        "reasoning": "数据流分析依据说明"\n    }\n}\n\n**再次强调：只返回上述JSON格式的内容，不要包含任何其他文字。**'}], 'model': 'qwen2.5:14b', 'max_tokens': 4000, 'response_format': {'type': 'json_object'}, 'temperature': 0.1, 'top_p': 0.1}}
2025-06-09 13:58:58,842 - openai._base_client - DEBUG - Sending HTTP Request: POST http://192.168.5.253:3000/api/chat/completions
2025-06-09 13:58:58,843 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-06-09 13:58:58,843 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-06-09 13:58:58,843 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-06-09 13:58:58,843 - httpcore.http11 - DEBUG - send_request_body.complete
2025-06-09 13:58:58,843 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
